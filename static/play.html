<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AURA // Music Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <style>
        @keyframes float {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(2vw, -5vh) rotate(2deg); }
            66% { transform: translate(-1vw, 3vh) rotate(-1deg); }
        }
        
        .animate-aura {
            animation: float 18s infinite ease-in-out;
        }

        @keyframes pulse-bar {
            0%, 100% { height: 20%; opacity: 0.5; }
            50% { height: 80%; opacity: 1; }
        }

        .playing .bar-anim {
            animation: pulse-bar 1s infinite ease-in-out;
        }

        .glass {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-hover:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .progress-bar {
            transition: width 0.1s linear;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Hide YouTube iframe but keep it functional */
        #youtube-player {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* 3D Cat Container */
        .cat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            z-index: 50;
            cursor: pointer;
            transition: transform 0.3s ease, bottom 0.3s ease, right 0.3s ease;
            will-change: transform;
            user-select: none;
            -webkit-user-select: none;
            overflow: visible;
            /* No border, background, or shadow - clean cat only */
        }

        .cat-container:hover {
            transform: scale(1.05);
        }

        .cat-container.following {
            transition: transform 0.1s ease, bottom 0.1s ease, right 0.1s ease;
        }

        .cat-container svg {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        
        .cat-svg {
            overflow: visible;
        }

        .cat-container.rolling-around {
            animation: catRollAround 3s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            will-change: transform;
        }

        @keyframes catRollAround {
            0% { transform: rotate(0deg) translateX(0) translateY(0) scale(1); }
            12.5% { transform: rotate(45deg) translateX(20px) translateY(-15px) scale(0.98); }
            25% { transform: rotate(90deg) translateX(35px) translateY(-30px) scale(0.96); }
            37.5% { transform: rotate(135deg) translateX(20px) translateY(-40px) scale(0.94); }
            50% { transform: rotate(180deg) translateX(0) translateY(-45px) scale(0.92); }
            62.5% { transform: rotate(225deg) translateX(-20px) translateY(-40px) scale(0.94); }
            75% { transform: rotate(270deg) translateX(-35px) translateY(-30px) scale(0.96); }
            87.5% { transform: rotate(315deg) translateX(-20px) translateY(-15px) scale(0.98); }
            100% { transform: rotate(360deg) translateX(0) translateY(0) scale(1); }
        }

        .cat-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        /* Cat Idle Animation */
        @keyframes catIdle {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(2deg); }
        }

        .cat-idle {
            animation: catIdle 3s ease-in-out infinite;
        }

        /* Cat Dancing Animation */
        @keyframes catDance {
            0%, 100% { transform: translateY(0) rotate(-5deg) scale(1); }
            25% { transform: translateY(-10px) rotate(5deg) scale(1.05); }
            50% { transform: translateY(-5px) rotate(-5deg) scale(1); }
            75% { transform: translateY(-10px) rotate(5deg) scale(1.05); }
        }

        .cat-dancing {
            animation: catDance 0.6s ease-in-out infinite;
        }

        /* Cat Happy Animation */
        @keyframes catHappy {
            0%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
            25% { transform: translateY(-8px) rotate(-3deg) scale(1.1); }
            50% { transform: translateY(-12px) rotate(3deg) scale(1.15); }
            75% { transform: translateY(-8px) rotate(-3deg) scale(1.1); }
        }

        .cat-happy {
            animation: catHappy 1s ease-in-out infinite;
        }

        /* Cat Sad Animation */
        @keyframes catSad {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(3px) rotate(-2deg); }
        }

        .cat-sad {
            animation: catSad 2s ease-in-out infinite;
            opacity: 0.7;
        }

        /* Cat Depressed Animation */
        @keyframes catDepressed {
            0%, 100% { transform: translateY(5px) rotate(-1deg); }
            50% { transform: translateY(8px) rotate(1deg); }
        }

        .cat-depressed {
            animation: catDepressed 3s ease-in-out infinite;
            opacity: 0.5;
            filter: grayscale(0.3);
        }

        /* Cat Excited Animation */
        @keyframes catExcited {
            0%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
            33% { transform: translateY(-15px) rotate(-10deg) scale(1.2); }
            66% { transform: translateY(-15px) rotate(10deg) scale(1.2); }
        }

        .cat-excited {
            animation: catExcited 0.4s ease-in-out infinite;
        }

        /* Cat Sleeping Animation */
        @keyframes catSleep {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(2px) rotate(1deg); }
        }

        .cat-sleeping {
            animation: catSleep 3s ease-in-out infinite;
            opacity: 0.6;
        }

        /* Cat Tail Animation */
        @keyframes tailWag {
            0%, 100% { transform: rotate(-10deg); }
            50% { transform: rotate(10deg); }
        }

        .cat-playing .cat-tail {
            animation: tailWag 0.5s ease-in-out infinite;
            transform-origin: 20px 15px;
        }

        /* Cat Ears Animation */
        @keyframes earTwitch {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(-5deg); }
        }

        .cat-listening .cat-ear {
            animation: earTwitch 2s ease-in-out infinite;
        }

        .cat-listening .cat-ear-right {
            animation: earTwitch 2s ease-in-out infinite;
            animation-delay: 0.1s;
        }

        /* Cat Eyes Blink */
        @keyframes blink {
            0%, 90%, 100% { transform: scaleY(1); }
            95% { transform: scaleY(0.1); }
        }

        .cat-eye {
            animation: blink 3s ease-in-out infinite;
        }

        .cat-eye-right {
            animation: blink 3s ease-in-out infinite;
            animation-delay: 0.1s;
        }

        /* Cat Speech Bubble */
        .cat-speech {
            position: absolute;
            bottom: 200px;
            right: 0;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(139, 92, 246, 0.5);
            border-radius: 16px;
            padding: 10px 16px;
            font-size: 14px;
            font-weight: 500;
            color: white;
            white-space: nowrap;
            opacity: 0;
            transform: translateY(10px) scale(0.9);
            transition: all 0.3s ease;
            pointer-events: none;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            max-width: 250px;
        }

        .cat-speech.show {
            opacity: 1;
            transform: translateY(0);
        }

        .cat-speech::after {
            content: '';
            position: absolute;
            bottom: -6px;
            right: 20px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(0, 0, 0, 0.8);
        }

        /* Cat Heart Particles */
        @keyframes heartFloat {
            0% { transform: translateY(0) scale(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-50px) scale(1.5) rotate(360deg); opacity: 0; }
        }

        .cat-heart {
            position: absolute;
            font-size: 24px;
            animation: heartFloat 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        /* Cat Star Particles */
        @keyframes starFloat {
            0% { transform: translateY(0) scale(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(-60px) scale(1.2) rotate(720deg); opacity: 0; }
        }

        .cat-star {
            position: absolute;
            font-size: 20px;
            animation: starFloat 2s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        /* Cat Sparkle Effect */
        @keyframes sparkle {
            0%, 100% { opacity: 0; transform: scale(0); }
            50% { opacity: 1; transform: scale(1); }
        }

        .cat-sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            animation: sparkle 0.6s ease-in-out infinite;
            pointer-events: none;
        }

        /* Cat Glow Effect */
        .cat-container.glow {
            filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.8)) drop-shadow(0 0 40px rgba(167, 139, 250, 0.6));
        }

        /* Cat Bounce Effect */
        @keyframes catBounce {
            0%, 100% { transform: translateY(0) scale(1); }
            50% { transform: translateY(-30px) scale(1.1); }
        }

        .cat-container.bouncing {
            animation: catBounce 0.6s ease-in-out;
        }

        /* Cat Spin Effect */
        @keyframes catSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .cat-container.spinning {
            animation: catSpin 0.8s ease-in-out;
        }
    </style>
</head>
<body class="bg-[#020202] text-white overflow-hidden" 
      x-data="playApp()" 
      x-init="init()">

    <!-- YouTube IFrame API -->
    <div id="youtube-player"></div>
    <!-- Client-side Ad Blocker -->
    <script src="/static/ad-blocker.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    
    <!-- GSAP for 2D Cat Animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <div class="fixed inset-0 z-0">
        <div class="absolute top-[-20%] left-[-10%] w-[70vw] h-[70vw] bg-purple-600/20 rounded-full blur-[120px] animate-aura"></div>
        <div class="absolute bottom-[-10%] right-[-10%] w-[60vw] h-[60vw] bg-blue-600/15 rounded-full blur-[120px] animate-aura" style="animation-delay: -9s;"></div>
    </div>

    <!-- Interactive 2D Cat -->
    <div class="cat-container" 
         x-data="catEmotion()"
         :class="[following ? 'following' : '', isRolling ? 'rolling-around' : '', isGlowing ? 'glow' : '', isBouncing ? 'bouncing' : '', isSpinning ? 'spinning' : '']"
         :style="`bottom: ${catY}px; right: ${catX}px;`"
         @click="interactWithCat()"
         @dblclick="rollCat()"
         @mouseenter="showSpeech('Meow! ðŸ±')"
         @mouseleave="hideSpeech()"
         @mousemove="handleMouseMove($event)"
         @mousedown="startDrag($event)"
         @mouseup="stopDrag()"
         draggable="false"
         id="cat-3d-container">
        <div class="cat-speech" :class="{ 'show': speechVisible }" x-text="speechText"></div>
        <!-- 2D Cat SVG will be rendered here -->
    </div>

    <div class="relative z-10 h-screen flex flex-col">
        
        <nav class="flex justify-between items-center p-6 md:p-8">
            <a href="/" class="text-2xl font-black tracking-tighter italic hover:opacity-80 transition-opacity">AURA.</a>
            <div class="glass px-4 py-2 rounded-full text-xs font-mono tracking-widest uppercase opacity-70">
                <span x-text="playing ? 'â–¶ Playing' : 'â¸ Paused'"></span>
            </div>
        </nav>

        <main class="flex-1 flex flex-col items-center justify-center px-6 text-center overflow-y-auto pb-32">
            
            <!-- Album Art -->
            <div class="mb-8 fade-in" x-show="currentSong">
                <div class="w-64 h-64 md:w-80 md:h-80 rounded-2xl overflow-hidden shadow-2xl glass border-2 border-white/10"
                     :class="playing ? 'animate-pulse' : ''">
                    <img :src="currentSong?.song?.image || 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23999\'%3E%3Cpath d=\'M9 18V5l12-2v13\'/%3E%3Ccircle cx=\'6\' cy=\'18\' r=\'3\'/%3E%3Ccircle cx=\'18\' cy=\'16\' r=\'3\'/%3E%3C/svg%3E'"
                         :alt="currentSong?.song?.title"
                         class="w-full h-full object-cover">
                </div>
            </div>

            <!-- Song Info -->
            <div class="mb-8 fade-in" x-show="currentSong">
                <h2 class="text-3xl md:text-4xl font-bold mb-2" x-text="currentSong?.song?.title || 'No song selected'"></h2>
                <p class="text-lg text-gray-400 mb-1" x-text="currentSong?.song?.artists?.join(', ') || 'Unknown Artist'"></p>
                <p class="text-sm text-gray-500" x-text="currentSong?.song?.album || ''"></p>
            </div>

            <!-- Visualizer -->
            <div class="mb-8">
                <div class="flex items-end justify-center space-x-1 h-16 md:h-20" :class="{ 'playing': playing }">
                    <template x-for="i in 20">
                        <div class="w-1 md:w-1.5 bg-gradient-to-t from-indigo-500 to-rose-500 rounded-full bar-anim" 
                             :style="`animation-delay: ${i * 0.05}s; height: ${playing ? '100%' : '20%'}`"></div>
                    </template>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="w-full max-w-md mb-8" x-show="currentSong">
                <div class="flex items-center justify-between text-xs text-gray-500 mb-2">
                    <span x-text="formatTime(currentTime)"></span>
                    <span x-text="formatTime(duration)"></span>
                </div>
                <div class="h-1 bg-white/10 rounded-full overflow-hidden cursor-pointer" @click="seekTo($event)">
                    <div class="h-full bg-gradient-to-r from-indigo-500 to-rose-500 progress-bar" 
                         :style="`width: ${progressPercent}%`"></div>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex items-center justify-center space-x-4 mb-8">
                <button @click="previousSong()" 
                        class="glass p-3 rounded-full hover:bg-white/10 transition-all active:scale-95"
                        :disabled="recommendations.length === 0">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.334 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z"/>
                    </svg>
                </button>
                
                <button @click="togglePlay()" 
                        class="glass p-6 rounded-full hover:bg-white/10 transition-all active:scale-95 relative group">
                    <div class="absolute inset-0 bg-gradient-to-r from-indigo-500 to-rose-500 rounded-full opacity-0 group-hover:opacity-20 transition-opacity"></div>
                    <template x-if="!playing">
                        <svg class="w-8 h-8 fill-white relative z-10" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                    </template>
                    <template x-if="playing">
                        <svg class="w-8 h-8 fill-white relative z-10" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                        </svg>
                    </template>
                </button>
                
                <button @click="nextSong()" 
                        class="glass p-3 rounded-full hover:bg-white/10 transition-all active:scale-95"
                        :disabled="recommendations.length === 0">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.933 12.8a1 1 0 000-1.6L6.6 7.2A1 1 0 005 8v8a1 1 0 001.6.8l5.333-4zM19.933 12.8a1 1 0 000-1.6l-5.333-4A1 1 0 0013 8v8a1 1 0 001.6.8l5.333-4z"/>
                    </svg>
                </button>
            </div>

            <!-- Explanation -->
            <div class="glass p-6 rounded-2xl max-w-md mb-6" x-show="currentSong?.explanation">
                <p class="text-xs text-gray-400 mb-2 uppercase tracking-widest">Why Recommended</p>
                <p class="text-sm leading-relaxed" x-text="currentSong?.explanation?.text || ''"></p>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-wrap items-center justify-center gap-3">
                <button @click="submitFeedback('like')" 
                        class="glass px-6 py-3 rounded-full text-sm hover:bg-rose-500/20 transition-all active:scale-95 flex items-center space-x-2"
                        :disabled="!currentSong">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"/>
                    </svg>
                    <span>Like</span>
                </button>
                
                <button @click="submitFeedback('skip')" 
                        class="glass px-6 py-3 rounded-full text-sm hover:bg-gray-600/20 transition-all active:scale-95 flex items-center space-x-2"
                        :disabled="!currentSong">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                    <span>Skip</span>
                </button>

                <a :href="currentSong?.platform_links?.spotify" 
                   target="_blank"
                   class="glass px-6 py-3 rounded-full text-sm hover:bg-green-500/20 transition-all active:scale-95 flex items-center space-x-2"
                   x-show="currentSong">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.281c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/>
                    </svg>
                    <span>Open in Spotify</span>
                </a>
            </div>

            <!-- Queue -->
            <div class="mt-8 w-full max-w-2xl" x-show="recommendations.length > 1">
                <p class="text-xs text-gray-500 uppercase tracking-widest mb-4 text-left">Up Next</p>
                <div class="space-y-2 max-h-48 overflow-y-auto">
                    <template x-for="(rec, index) in recommendations.slice(1, 6)" :key="index">
                        <div @click="playSong(rec)"
                             class="glass p-3 rounded-lg cursor-pointer hover:bg-white/5 transition-all flex items-center space-x-3"
                             :class="currentSong?.recommendation_id === rec.recommendation_id ? 'ring-2 ring-indigo-500' : ''">
                            <img :src="rec.song?.image || ''" 
                                 :alt="rec.song?.title"
                                 class="w-12 h-12 rounded object-cover">
                            <div class="flex-1 min-w-0 text-left">
                                <p class="font-medium truncate" x-text="rec.song?.title"></p>
                                <p class="text-xs text-gray-400 truncate" x-text="rec.song?.artists?.join(', ')"></p>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Empty State -->
            <div x-show="!currentSong && !loading" class="text-center py-20">
                <svg class="w-20 h-20 mx-auto mb-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
                </svg>
                <p class="text-gray-500 mb-2 text-lg">No song selected</p>
                <p class="text-sm text-gray-600 mb-6">Get recommendations to start playing</p>
                <a href="/" class="glass px-6 py-3 rounded-full hover:bg-white hover:text-black transition-all active:scale-95 inline-block">
                    Get Recommendations
                </a>
            </div>
        </main>
    </div>

    <script>
        // Auto-detect API URL
        const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8000/api/v1'
            : window.location.origin + '/api/v1';
        
        let ytPlayer = null;
        let ytApiReady = false;

        // YouTube IFrame API callback
        function onYouTubeIframeAPIReady() {
            ytApiReady = true;
            if (window.playAppInstance) {
                window.playAppInstance.initPlayer();
            }
        }

        function playApp() {
            return {
                playing: false,
                currentSong: null,
                recommendations: [],
                currentTime: 0,
                duration: 0,
                progressPercent: 0,
                loading: true,
                userId: localStorage.getItem('aura_user_id') || 'user_' + Math.random().toString(36).substr(2, 9),
                adMonitoringInterval: null,

                init() {
                    localStorage.setItem('aura_user_id', this.userId);
                    window.playAppInstance = this;
                    
                    // Check if song ID is in URL
                    const urlParams = new URLSearchParams(window.location.search);
                    const songId = urlParams.get('song');
                    
                    if (songId) {
                        this.loadSongFromId(songId);
                    } else {
                        this.loadRecommendations();
                    }
                    
                    // Initialize YouTube player when API is ready
                    if (ytApiReady) {
                        this.initPlayer();
                    }
                    
                    // Update progress every second
                    setInterval(() => this.updateProgress(), 1000);
                },

                initPlayer() {
                    if (ytPlayer) return;
                    
                    // Create player with nocookie domain (fewer ads)
                    // We'll override the embed URL to use nocookie domain
                    ytPlayer = new YT.Player('youtube-player', {
                        height: '1',
                        width: '1',
                        playerVars: {
                            'autoplay': 0,
                            'controls': 0,
                            'disablekb': 1,
                            'enablejsapi': 1,
                            'fs': 0,
                            'iv_load_policy': 3,
                            'modestbranding': 1,
                            'playsinline': 1,
                            'rel': 0,
                            'cc_load_policy': 0,  // Don't load captions
                            'loop': 0,
                            'mute': 0,
                            'start': 0,
                            // Ad blocking parameters
                            'origin': window.location.origin,
                            'widget_referrer': window.location.origin
                        },
                        events: {
                            'onReady': (event) => {
                                console.log('YouTube player ready');
                            },
                            'onStateChange': (event) => {
                                if (event.data === YT.PlayerState.PLAYING) {
                                    this.playing = true;
                                    this.syncCatState();
                                    
                                    // Start aggressive ad monitoring
                                    this.startAdMonitoring();
                                    
                                    // Immediate ad detection
                                    setTimeout(() => this.detectAndSkipAds(), 500);
                                    setTimeout(() => this.detectAndSkipAds(), 1500);
                                    setTimeout(() => this.detectAndSkipAds(), 3000);
                                } else if (event.data === YT.PlayerState.PAUSED) {
                                    this.playing = false;
                                    this.syncCatState();
                                    this.stopAdMonitoring();
                                } else if (event.data === YT.PlayerState.ENDED) {
                                    this.playing = false;
                                    this.syncCatState();
                                    this.stopAdMonitoring();
                                    this.nextSong();
                                } else if (event.data === YT.PlayerState.CUED) {
                                    // Video is cued (often happens before ads)
                                    this.detectAndSkipAds();
                                } else if (event.data === YT.PlayerState.ERROR) {
                                    console.error('YouTube player error - video may be unavailable');
                                    this.stopAdMonitoring();
                                    // Try to skip to next song if current one fails
                                    if (this.currentSong) {
                                        alert(`Unable to play "${this.currentSong.song?.title || 'this song'}". Skipping to next song.`);
                                    this.nextSong();
                                    }
                                }
                            },
                            'onError': (event) => {
                                console.error('YouTube player error code:', event.data);
                                // Error codes: 2=invalid video, 5=HTML5 error, 100=video not found, 101/150=not allowed to embed
                                const errorMessages = {
                                    2: 'Invalid video parameter',
                                    5: 'HTML5 player error',
                                    100: 'Video not found',
                                    101: 'Video not allowed to be played in embedded players',
                                    150: 'Video not allowed to be played in embedded players'
                                };
                                const errorMsg = errorMessages[event.data] || 'Unknown error';
                                console.error('YouTube error:', errorMsg);
                                
                                // For invalid video parameter (error 2), try to refetch video ID
                                if (event.data === 2 && this.currentSong && !this.currentSong._retryAttempted) {
                                    console.log('Invalid video ID detected, attempting to refetch...');
                                    this.currentSong._retryAttempted = true;
                                    this.currentSong.youtube_video_id = null;
                                    if (this.currentSong.song) {
                                        this.currentSong.song.youtube_video_id = null;
                                    }
                                    
                                    // Refetch video ID with a slight delay
                                    setTimeout(async () => {
                                        await this.fetchYouTubeVideoId(this.currentSong);
                                        const newVideoId = this.currentSong.youtube_video_id || this.currentSong.song?.youtube_video_id;
                                        if (newVideoId) {
                                            console.log('Retrying with new video ID:', newVideoId);
                                            this.loadSong(this.currentSong);
                                        } else {
                                            // If still no valid video ID, skip to next
                                            alert(`Unable to find a valid YouTube video for "${this.currentSong.song?.title || 'this song'}". Skipping to next song.`);
                                            this.nextSong();
                                        }
                                    }, 1000);
                                } else {
                                    // For other errors or if retry already attempted, skip to next song
                                    if (this.currentSong) {
                                        alert(`Unable to play "${this.currentSong.song?.title || 'this song'}": ${errorMsg}. Skipping to next song.`);
                                        this.nextSong();
                                    }
                                }
                            }
                        }
                    });
                },

                async loadRecommendations(preserveCurrentSong = false, genre = null) {
                    this.loading = true;
                    try {
                        // Build URL with optional genre parameter
                        let url = `${API_BASE}/recommendations?user_id=${this.userId}&limit=10`;
                        if (genre) {
                            url += `&genre=${encodeURIComponent(genre)}`;
                        }
                        
                        const response = await fetch(url);
                        const data = await response.json();
                        if (data.recommendations && data.recommendations.length > 0) {
                            this.recommendations = data.recommendations;
                            // Only set currentSong if we're not preserving it (i.e., when loading initial recommendations)
                            if (!preserveCurrentSong) {
                            this.currentSong = this.recommendations[0];
                            this.loadSong(this.currentSong);
                                this.syncCatState();
                            }
                        }
                    } catch (error) {
                        console.error('Error loading recommendations:', error);
                    } finally {
                        this.loading = false;
                    }
                },

                async loadSongFromId(songId) {
                    this.loading = true;
                    try {
                        // Check if songId is a JSON string (from search results)
                        let songData = null;
                        try {
                            songData = JSON.parse(decodeURIComponent(songId));
                            // If parsing succeeds, it's a song object from search
                            if (songData.title) {
                                // Create a recommendation-like object from the song data
                                const songObj = {
                                    recommendation_id: `search_${Date.now()}`,
                                    song: {
                                        title: songData.title,
                                        artists: songData.artists || [],
                                        image: songData.image || '',
                                        album: songData.album || '',
                                        genre: songData.genre || [],
                                        youtube_video_id: songData.youtube_video_id || null
                                    },
                                    youtube_video_id: songData.youtube_video_id || null
                                };
                                
                                // Fetch YouTube video ID if not present
                                if (!songObj.youtube_video_id && !songObj.song.youtube_video_id) {
                                    await this.fetchYouTubeVideoId(songObj);
                                }
                                
                                this.currentSong = songObj;
                                this.loadSong(songObj);
                                this.syncCatState();
                                
                                // Extract genre from the searched song
                                const songGenres = songObj.song?.genre || songData.genre || [];
                                const genreParam = songGenres.length > 0 ? songGenres.join(',') : null;
                                
                                // Load recommendations for queue (preserve current song) with genre filter
                                await this.loadRecommendations(true, genreParam);
                                
                                // Insert the searched song at the beginning of recommendations queue
                                if (this.recommendations.length > 0) {
                                    this.recommendations.unshift(songObj);
                                } else {
                                    this.recommendations = [songObj];
                                }
                                return;
                            }
                        } catch (e) {
                            // Not a JSON string, treat as recommendation_id
                        }
                        
                        // Try to find in recommendations
                        const response = await fetch(`${API_BASE}/recommendations?user_id=${this.userId}&limit=50`);
                        const data = await response.json();
                        if (data.recommendations) {
                            this.recommendations = data.recommendations;
                            const song = data.recommendations.find(r => r.recommendation_id === songId);
                            if (song) {
                                this.currentSong = song;
                                // Fetch YouTube video ID if not present
                                if (!song.youtube_video_id && !song.song?.youtube_video_id) {
                                    await this.fetchYouTubeVideoId(song);
                                }
                                this.loadSong(song);
                            } else if (data.recommendations.length > 0) {
                                this.currentSong = data.recommendations[0];
                                if (!this.currentSong.youtube_video_id && !this.currentSong.song?.youtube_video_id) {
                                    await this.fetchYouTubeVideoId(this.currentSong);
                                }
                                this.loadSong(this.currentSong);
                            }
                        }
                    } catch (error) {
                        console.error('Error loading song:', error);
                    } finally {
                        this.loading = false;
                    }
                },
                
                async fetchYouTubeVideoId(song, retryCount = 0) {
                    try {
                        const title = song.song?.title || song.title;
                        const artists = song.song?.artists || song.artists || [];
                        const artistsStr = Array.isArray(artists) ? artists.join(',') : artists;
                        
                        if (!title) return;
                        
                        const response = await fetch(
                            `${API_BASE}/songs/youtube-video-id?title=${encodeURIComponent(title)}&artists=${encodeURIComponent(artistsStr)}`
                        );
                        const data = await response.json();
                        
                        if (data.youtube_video_id) {
                            // Validate video ID format
                            const videoId = data.youtube_video_id.trim();
                            if (videoId.length === 11 && /^[a-zA-Z0-9_-]+$/.test(videoId)) {
                            // Update song object with video ID
                            if (song.song) {
                                    song.song.youtube_video_id = videoId;
                            }
                                song.youtube_video_id = videoId;
                            
                            // If this is the current song and player is ready, load it
                            if (this.currentSong === song && ytPlayer) {
                                this.loadSong(song);
                            }
                            } else {
                                console.error('Invalid video ID format:', videoId);
                                // Retry if we haven't retried too many times
                                if (retryCount < 2) {
                                    setTimeout(() => this.fetchYouTubeVideoId(song, retryCount + 1), 1000);
                                }
                            }
                        } else if (retryCount < 2) {
                            // Retry if no video ID found
                            setTimeout(() => this.fetchYouTubeVideoId(song, retryCount + 1), 1000);
                        }
                    } catch (error) {
                        console.error('Error fetching YouTube video ID:', error);
                        // Retry on error
                        if (retryCount < 2) {
                            setTimeout(() => this.fetchYouTubeVideoId(song, retryCount + 1), 1000);
                        }
                    }
                },

                async loadSong(song) {
                    if (!song) return;
                    
                    // Ensure we have a video ID
                    let videoId = song.youtube_video_id || song.song?.youtube_video_id;
                    
                    if (!videoId) {
                        // Try to fetch it
                        await this.fetchYouTubeVideoId(song);
                        videoId = song.youtube_video_id || song.song?.youtube_video_id;
                    }
                    
                    if (!videoId) {
                        console.error('No video ID found for song:', song.song?.title || song.title);
                        alert(`Could not find YouTube video for "${song.song?.title || song.title}". Please try another song.`);
                        return;
                    }
                    
                    if (!ytPlayer) {
                        console.error('YouTube player not ready');
                        // Wait a bit and try again
                        setTimeout(() => this.loadSong(song), 500);
                        return;
                    }
                    
                    // Validate video ID before loading
                    if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
                        console.error('Invalid video ID format:', videoId);
                        alert(`Invalid video ID for "${song.song?.title || song.title}". Please try another song.`);
                        return;
                    }
                    
                    try {
                        // Stop any existing ad monitoring
                        this.stopAdMonitoring();
                        
                        // Force use of nocookie domain for fewer ads
                        const playerElement = document.getElementById('youtube-player');
                        if (playerElement) {
                            const iframe = playerElement.querySelector('iframe');
                            if (iframe && iframe.src) {
                                // Replace youtube.com with youtube-nocookie.com
                                iframe.src = iframe.src.replace('youtube.com', 'youtube-nocookie.com');
                            }
                        }
                        
                        ytPlayer.loadVideoById(videoId);
                        this.playing = false;
                        this.currentTime = 0;
                        this.duration = 0;
                        
                        // Start monitoring for ads after video loads
                        setTimeout(() => {
                            if (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                                this.startAdMonitoring();
                            }
                        }, 1000);
                    } catch (error) {
                        console.error('Error loading video:', error);
                        // Try to refetch video ID if loading fails
                        if (!song._retryAttempted) {
                            song._retryAttempted = true;
                            console.log('Retrying with new video ID...');
                            await this.fetchYouTubeVideoId(song);
                            const newVideoId = song.youtube_video_id || song.song?.youtube_video_id;
                            if (newVideoId && newVideoId !== videoId) {
                                setTimeout(() => this.loadSong(song), 500);
                            }
                        }
                    }
                },

                playSong(song) {
                    // Stop any existing ad monitoring
                    this.stopAdMonitoring();
                    
                    this.currentSong = song;
                    this.loadSong(song);
                    this.syncCatState();
                },

                togglePlay() {
                    if (!ytPlayer || !this.currentSong) return;
                    
                    if (this.playing) {
                        ytPlayer.pauseVideo();
                    } else {
                        ytPlayer.playVideo();
                    }
                },

                nextSong() {
                    // Stop ad monitoring when skipping
                    this.stopAdMonitoring();
                    
                    if (this.recommendations.length === 0) return;
                    
                    const currentIndex = this.recommendations.findIndex(r => 
                        r.recommendation_id === this.currentSong?.recommendation_id
                    );
                    const nextIndex = (currentIndex + 1) % this.recommendations.length;
                    this.playSong(this.recommendations[nextIndex]);
                },

                previousSong() {
                    if (this.recommendations.length === 0) return;
                    
                    const currentIndex = this.recommendations.findIndex(r => 
                        r.recommendation_id === this.currentSong?.recommendation_id
                    );
                    const prevIndex = currentIndex <= 0 ? this.recommendations.length - 1 : currentIndex - 1;
                    this.playSong(this.recommendations[prevIndex]);
                },

                detectAndSkipAds() {
                    // Enhanced ad detection and skipping
                    if (!ytPlayer) return;
                    
                    try {
                        const duration = ytPlayer.getDuration();
                        const currentTime = ytPlayer.getCurrentTime();
                        const videoData = ytPlayer.getVideoData ? ytPlayer.getVideoData() : null;
                        
                        // Method 1: Detect ads by duration (ads are typically 5-30 seconds)
                        // But be careful - some songs are short too
                        if (duration > 0 && duration <= 35 && currentTime < 10) {
                            // Check if this is likely an ad (very short, just started)
                            const isLikelyAd = duration <= 35 && currentTime < 5;
                            
                            if (isLikelyAd) {
                                console.log(`Detected potential ad (${duration}s), attempting to skip...`);
                                
                                // Try to seek to end of ad
                                try {
                                    ytPlayer.seekTo(duration - 0.5, true);
                                    console.log('Sought to end of ad');
                                } catch (e) {
                                    console.debug('Could not seek:', e);
                                }
                                
                                // If still playing after 2 seconds, skip to next song
                                setTimeout(() => {
                                    if (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                                        const newTime = ytPlayer.getCurrentTime();
                                        const newDuration = ytPlayer.getDuration();
                                        
                                        // If still a short video, it's likely an ad
                                        if (newDuration <= 35 && newTime < newDuration - 1) {
                                            console.log('Ad detected, skipping to next song');
                                            this.nextSong();
                                        }
                                    }
                                }, 2000);
                            }
                        }
                        
                        // Method 2: Detect ads by checking if video title/author suggests it's an ad
                        if (videoData) {
                            const title = (videoData.title || '').toLowerCase();
                            const author = (videoData.author || '').toLowerCase();
                            
                            // Common ad indicators
                            const adKeywords = ['advertisement', 'ad', 'sponsored', 'promo', 'commercial'];
                            const isAdByTitle = adKeywords.some(keyword => title.includes(keyword));
                            
                            if (isAdByTitle && duration <= 60) {
                                console.log('Ad detected by title, skipping...');
                                this.nextSong();
                                return;
                            }
                        }
                        
                        // Method 3: Monitor for sudden state changes that might indicate ads
                        // This will be handled by the onStateChange handler
                        
                    } catch (e) {
                        console.debug('Ad detection error:', e);
                    }
                },
                
                // Enhanced ad monitoring with interval
                startAdMonitoring() {
                    // Clear any existing interval
                    if (this.adMonitoringInterval) {
                        clearInterval(this.adMonitoringInterval);
                    }
                    
                    // Monitor for ads every 500ms when playing
                    this.adMonitoringInterval = setInterval(() => {
                        if (this.playing && ytPlayer) {
                            this.detectAndSkipAds();
                        }
                    }, 500);
                },
                
                stopAdMonitoring() {
                    if (this.adMonitoringInterval) {
                        clearInterval(this.adMonitoringInterval);
                        this.adMonitoringInterval = null;
                    }
                },

                updateProgress() {
                    if (!ytPlayer || !this.currentSong) return;
                    
                    try {
                        this.currentTime = ytPlayer.getCurrentTime() || 0;
                        this.duration = ytPlayer.getDuration() || 0;
                        this.progressPercent = this.duration > 0 ? (this.currentTime / this.duration) * 100 : 0;
                    } catch (e) {
                        // Player might not be ready
                    }
                },

                seekTo(event) {
                    if (!ytPlayer || !this.currentSong) return;
                    
                    const rect = event.currentTarget.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const percent = x / rect.width;
                    const time = percent * this.duration;
                    ytPlayer.seekTo(time, true);
                },

                formatTime(seconds) {
                    if (!seconds || isNaN(seconds)) return '0:00';
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                },

                async submitFeedback(type) {
                    if (!this.currentSong) return;
                    
                    try {
                        await fetch(`${API_BASE}/feedback`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                user_id: this.userId,
                                recommendation_id: this.currentSong.recommendation_id,
                                song_id: this.currentSong.song?.title || this.currentSong.recommendation_id,
                                feedback_type: type,
                                context: { time_of_day: this.getTimeOfDay() }
                            })
                        });
                        
                        // Track listening if liked
                        if (type === 'like' && this.currentSong.song) {
                            await fetch(`${API_BASE}/listening/track`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    user_id: this.userId,
                                    song_title: this.currentSong.song.title,
                                    artists: this.currentSong.song.artists || [],
                                    source: 'recommendation',
                                    platform: 'youtube',
                                    metadata: {}
                                })
                            });
                        }
                        
                        if (type === 'skip') {
                            this.nextSong();
                        }
                    } catch (error) {
                        console.error('Error submitting feedback:', error);
                    }
                },

                getTimeOfDay() {
                    const hour = new Date().getHours();
                    if (hour < 12) return 'morning';
                    if (hour < 17) return 'afternoon';
                    if (hour < 21) return 'evening';
                    return 'night';
                },

                syncCatState() {
                    // Sync state with Alpine store for cat to react
                    if (window.Alpine && window.Alpine.store) {
                        try {
                            window.Alpine.store('playApp', {
                                playing: this.playing,
                                currentSong: this.currentSong
                            });
                        } catch (e) {
                            // Store might not be initialized yet
                        }
                    }
                }
            }
        }

        // Cat Emotion System
        function catEmotion() {
            return {
                emotion: 'idle',  // Initialize with 'idle' to prevent undefined errors
                catState: 'cat-idle',
                speechVisible: false,
                speechText: '',
                lastSongTitle: '',
                interactionCount: 0,
                catX: 20,
                catY: 20,
                following: false,
                mouseX: 0,
                mouseY: 0,
                isRolling: false,
                isRollingAround: false,
                isGlowing: false,
                isBouncing: false,
                isSpinning: false,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                lastClickTime: 0,
                autoRollInterval: null,
                
                init() {
                    // Ensure emotion is always defined to prevent Alpine.js errors
                    if (!this.emotion || this.emotion === undefined) {
                        this.emotion = 'idle';
                    }
                    
                    // Update emotion periodically and watch for changes
                    const updateInterval = setInterval(() => {
                        this.updateEmotion();
                        this.checkForNewSong();
                        this.updatePosition();
                    }, 100);
                    
                    // Track mouse position globally
                    document.addEventListener('mousemove', (e) => {
                        this.mouseX = e.clientX;
                        this.mouseY = e.clientY;
                    });
                    
                    // Cleanup on component destroy
                    this.$el.addEventListener('alpine:destroyed', () => {
                        clearInterval(updateInterval);
                    });
                },
                
                handleMouseMove(event) {
                    // Handle dragging - no boundaries
                    if (this.isDragging) {
                        const newX = window.innerWidth - (event.clientX - this.dragStartX + this.$el.offsetWidth);
                        const newY = window.innerHeight - (event.clientY - this.dragStartY + this.$el.offsetHeight);
                        this.catX = newX;
                        this.catY = newY;
                        return;
                    }
                    
                    // Slight follow effect when mouse is near
                    const rect = this.$el.getBoundingClientRect();
                    const catCenterX = rect.left + rect.width / 2;
                    const catCenterY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(
                        Math.pow(event.clientX - catCenterX, 2) + 
                        Math.pow(event.clientY - catCenterY, 2)
                    );
                    
                    if (distance < 200) {
                        this.following = true;
                        const followStrength = 0.12;
                        const deltaX = (event.clientX - catCenterX) * followStrength;
                        const deltaY = (event.clientY - catCenterY) * followStrength;
                        
                        // Calculate new position from right and bottom - no boundaries
                        const newRight = window.innerWidth - (rect.right - deltaX);
                        const newBottom = window.innerHeight - (rect.bottom - deltaY);
                        
                        this.catX = newRight;
                        this.catY = newBottom;
                    } else {
                        this.following = false;
                    }
                },
                
                updatePosition() {
                    // Autonomous wandering when not following and not dragging
                    if (!this.following && !this.isDragging) {
                        // Cat moves around independently with gentle drift
                        const time = Date.now() / 2000; // Slower movement
                        const wanderX = 20 + Math.sin(time * 0.3) * 40;
                        const wanderY = 20 + Math.cos(time * 0.4) * 35;
                        
                        this.catX += (wanderX - this.catX) * 0.02;
                        this.catY += (wanderY - this.catY) * 0.02;
                    }
                },
                
                async checkForNewSong() {
                    const playApp = window.playAppInstance;
                    if (playApp && playApp.currentSong) {
                        const currentTitle = playApp.currentSong.song?.title || playApp.currentSong.title;
                        if (currentTitle && currentTitle !== this.lastSongTitle) {
                            this.lastSongTitle = currentTitle;
                            
                            // Simple reaction to new song
                            this.setEmotion('excited', 2000);
                            this.showSpeech('New song! ðŸŽµ', 2000);
                        }
                    }
                },
                
                updateEmotion() {
                    const playApp = window.playAppInstance;
                    if (!playApp) return;
                    
                    if (playApp.playing) {
                        // Dancing when music is playing
                        this.setEmotion('dancing');
                        // Trigger 3D dance animation
                        if (window.catDance) {
                            window.catDance();
                        }
                        // Auto-roll occasionally when music is playing
                        if (!this.autoRollInterval && Math.random() < 0.01) {
                            this.rollAround();
                        }
                    } else if (playApp.currentSong) {
                        // Happy but paused
                        this.setEmotion('happy');
                    } else {
                        // Sleeping when no song
                        this.setEmotion('sleeping');
                    }
                },
                
                setEmotion(newEmotion, duration = null) {
                    this.emotion = newEmotion || 'idle';
                    
                    // Remove all emotion classes
                    const classes = ['cat-idle', 'cat-dancing', 'cat-happy', 'cat-sad', 'cat-excited', 'cat-sleeping', 'cat-depressed', 'cat-playing', 'cat-listening'];
                    classes.forEach(cls => {
                        if (this.catState.includes(cls)) {
                            this.catState = this.catState.replace(cls, '').trim();
                        }
                    });
                    
                    // Add new emotion class
                    this.catState = `cat-${newEmotion}`;
                    
                    // Add playing class if music is playing
                    if (window.playAppInstance?.playing) {
                        this.catState += ' cat-playing cat-listening';
                    }
                    
                    // Reset after duration if specified
                    if (duration) {
                        setTimeout(() => {
                            this.updateEmotion();
                        }, duration);
                    }
                },
                
                interactWithCat() {
                    this.interactionCount++;
                    const playApp = window.playAppInstance;
                    
                    // Check for double click
                    const now = Date.now();
                    if (now - this.lastClickTime < 300) {
                        // Double click detected - roll!
                        this.rollCat();
                        this.lastClickTime = 0;
                        return;
                    }
                    this.lastClickTime = now;
                    
                    const messages = [
                        'Purr purr! ðŸ¾',
                        'Meow! Play me some music! ðŸŽµ',
                        'I love this song! ðŸ’œ',
                        'Scratch my ears! ðŸ˜¸',
                        'More music please! ðŸŽ¶',
                        'You\'re the best! â­',
                        'This beat is purrfect! ðŸŽµ',
                        'Keep the music coming! ðŸŽ§',
                        'Double click to see me roll! ðŸŽ²',
                        'I\'m having so much fun! ðŸŽ‰',
                        'Wheee! This is awesome! ðŸŒŸ'
                    ];
                    
                    const randomMessage = messages[Math.floor(Math.random() * messages.length)];
                    this.showSpeech(randomMessage, 2000);
                    
                    // Set excited emotion briefly
                    this.setEmotion('excited', 1500);
                    
                    // Add glow effect
                    this.addGlow();
                    
                    // Create heart and star particles
                    this.createHearts();
                    this.createStars();
                    this.createSparkles();
                },
                
                rollCat() {
                    if (this.isRolling) return;
                    
                    this.isRolling = true;
                    this.showSpeech('Wheee! Rolling! ðŸŽ²', 2000);
                    this.createStars();
                    
                    // Trigger 3D roll animation
                    if (window.doCatRoll) {
                        window.doCatRoll(1);
                    }
                    
                    // Smooth transition
                    this.$el.style.transition = 'transform 0.2s cubic-bezier(0.4, 0, 0.2, 1)';
                    
                    setTimeout(() => {
                        this.isRolling = false;
                        this.$el.style.transition = '';
                    }, 1500);
                },
                
                rollAround() {
                    if (this.isRollingAround) return;
                    
                    this.isRollingAround = true;
                    this.showSpeech('Rolling around! ðŸŽª', 3000);
                    this.createSparkles();
                    
                    // Smooth transition
                    this.$el.style.transition = 'transform 0.3s cubic-bezier(0.4, 0, 0.2, 1)';
                    
                    setTimeout(() => {
                        this.isRollingAround = false;
                        this.$el.style.transition = '';
                    }, 3000);
                },
                
                addGlow() {
                    this.isGlowing = true;
                    setTimeout(() => {
                        this.isGlowing = false;
                    }, 2000);
                },
                
                bounce() {
                    this.isBouncing = true;
                    setTimeout(() => {
                        this.isBouncing = false;
                    }, 600);
                },
                
                spin() {
                    this.isSpinning = true;
                    setTimeout(() => {
                        this.isSpinning = false;
                    }, 800);
                },
                
                startDrag(event) {
                    if (event.button !== 0) return; // Only left mouse button
                    this.isDragging = true;
                    const rect = this.$el.getBoundingClientRect();
                    this.dragStartX = event.clientX - rect.left;
                    this.dragStartY = event.clientY - rect.top;
                    this.$el.style.cursor = 'grabbing';
                },
                
                stopDrag() {
                    if (this.isDragging) {
                        this.isDragging = false;
                        this.$el.style.cursor = 'pointer';
                        this.bounce();
                    }
                },
                
                createHearts() {
                    const catContainer = this.$el;
                    const heartEmojis = ['ðŸ’œ', 'â¤ï¸', 'ðŸ’•', 'ðŸ’–', 'ðŸ’—'];
                    for (let i = 0; i < 5; i++) {
                        setTimeout(() => {
                            const heart = document.createElement('div');
                            heart.className = 'cat-heart';
                            heart.textContent = heartEmojis[Math.floor(Math.random() * heartEmojis.length)];
                            heart.style.left = `${50 + (Math.random() - 0.5) * 60}%`;
                            heart.style.top = `${50 + (Math.random() - 0.5) * 60}%`;
                            catContainer.appendChild(heart);
                            
                            setTimeout(() => heart.remove(), 1500);
                        }, i * 150);
                    }
                },
                
                createStars() {
                    const catContainer = this.$el;
                    const starEmojis = ['â­', 'âœ¨', 'ðŸŒŸ', 'ðŸ’«'];
                    for (let i = 0; i < 8; i++) {
                        setTimeout(() => {
                            const star = document.createElement('div');
                            star.className = 'cat-star';
                            star.textContent = starEmojis[Math.floor(Math.random() * starEmojis.length)];
                            star.style.left = `${50 + (Math.random() - 0.5) * 80}%`;
                            star.style.top = `${50 + (Math.random() - 0.5) * 80}%`;
                            catContainer.appendChild(star);
                            
                            setTimeout(() => star.remove(), 2000);
                        }, i * 100);
                    }
                },
                
                createSparkles() {
                    const catContainer = this.$el;
                    for (let i = 0; i < 12; i++) {
                        setTimeout(() => {
                            const sparkle = document.createElement('div');
                            sparkle.className = 'cat-sparkle';
                            sparkle.style.left = `${Math.random() * 100}%`;
                            sparkle.style.top = `${Math.random() * 100}%`;
                            sparkle.style.animationDelay = `${Math.random() * 0.6}s`;
                            catContainer.appendChild(sparkle);
                            
                            setTimeout(() => sparkle.remove(), 1000);
                        }, i * 50);
                    }
                },
                
                showSpeech(text, duration = 3000) {
                    this.speechText = text;
                    this.speechVisible = true;
                    
                    if (duration) {
                        setTimeout(() => {
                            this.hideSpeech();
                        }, duration);
                    }
                },
                
                hideSpeech() {
                    this.speechVisible = false;
                }
            }
        }

        // Initialize 2D Cat SVG
        function init2DCat() {
            const catContainer = document.getElementById('cat-3d-container');
            if (!catContainer) {
                setTimeout(init2DCat, 200);
                return;
            }

            // Check if already initialized
            if (catContainer.querySelector('svg')) {
                return;
            }

            // Create SVG cat with improved design
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('viewBox', '0 0 200 200');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            svg.classList.add('cat-svg');

            // Define gradients
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            
            // Gradient from indigo to rose (matching button style)
            const bodyGradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            bodyGradient.setAttribute('id', 'bodyGradient');
            bodyGradient.setAttribute('x1', '0%');
            bodyGradient.setAttribute('y1', '0%');
            bodyGradient.setAttribute('x2', '100%');
            bodyGradient.setAttribute('y2', '100%');
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#6366f1'); // indigo-500
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', '#f43f5e'); // rose-500
            bodyGradient.appendChild(stop1);
            bodyGradient.appendChild(stop2);
            defs.appendChild(bodyGradient);

            svg.appendChild(defs);

            // Body (more cat-like proportions - wider body)
            const body = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            body.setAttribute('cx', '100');
            body.setAttribute('cy', '130');
            body.setAttribute('rx', '50');
            body.setAttribute('ry', '45');
            body.setAttribute('fill', 'url(#bodyGradient)');
            body.setAttribute('class', 'cat-body');
            svg.appendChild(body);

            // Head (smaller, more proportional to body - cat-like)
            const head = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            head.setAttribute('cx', '100');
            head.setAttribute('cy', '80');
            head.setAttribute('rx', '40');
            head.setAttribute('ry', '35');
            head.setAttribute('fill', 'url(#bodyGradient)');
            svg.appendChild(head);

            // Left ear (more cat-like - wider base, proper positioning)
            const earL = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            earL.setAttribute('points', '68,55 75,35 82,55');
            earL.setAttribute('fill', 'url(#bodyGradient)');
            earL.setAttribute('class', 'cat-ear cat-ear-left');
            svg.appendChild(earL);

            // Right ear (more cat-like - wider base, proper positioning)
            const earR = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            earR.setAttribute('points', '118,35 125,55 132,55');
            earR.setAttribute('fill', 'url(#bodyGradient)');
            earR.setAttribute('class', 'cat-ear cat-ear-right');
            svg.appendChild(earR);

            // Left eye (smaller, more cat-like - almond shape)
            const eyeL = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            eyeL.setAttribute('cx', '88');
            eyeL.setAttribute('cy', '90');
            eyeL.setAttribute('rx', '7');
            eyeL.setAttribute('ry', '9');
            eyeL.setAttribute('fill', '#000000');
            eyeL.setAttribute('class', 'cat-eye cat-eye-left');
            svg.appendChild(eyeL);

            // Left eye pupil (yellow/orange oval - smaller, more cat-like)
            const pupilL = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            pupilL.setAttribute('cx', '88');
            pupilL.setAttribute('cy', '90');
            pupilL.setAttribute('rx', '3');
            pupilL.setAttribute('ry', '4');
            pupilL.setAttribute('fill', '#ffa500'); // Bright orange/yellow
            svg.appendChild(pupilL);

            // Right eye (smaller, more cat-like - almond shape)
            const eyeR = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            eyeR.setAttribute('cx', '112');
            eyeR.setAttribute('cy', '90');
            eyeR.setAttribute('rx', '7');
            eyeR.setAttribute('ry', '9');
            eyeR.setAttribute('fill', '#000000');
            eyeR.setAttribute('class', 'cat-eye cat-eye-right');
            svg.appendChild(eyeR);

            // Right eye pupil (yellow/orange oval - smaller, more cat-like)
            const pupilR = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            pupilR.setAttribute('cx', '112');
            pupilR.setAttribute('cy', '90');
            pupilR.setAttribute('rx', '3');
            pupilR.setAttribute('ry', '4');
            pupilR.setAttribute('fill', '#ffa500'); // Bright orange/yellow
            svg.appendChild(pupilR);

            // Nose (pink inverted triangle - cat-like)
            const nose = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            nose.setAttribute('points', '100,105 96,110 104,110');
            nose.setAttribute('fill', '#ff69b4'); // Pink
            svg.appendChild(nose);

            // Mouth (simple downward curved line - neutral/slightly sad)
            const mouth = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            mouth.setAttribute('d', 'M 100 110 Q 95 115 90 113');
            mouth.setAttribute('stroke', '#ff69b4'); // Pink
            mouth.setAttribute('stroke-width', '2');
            mouth.setAttribute('fill', 'none');
            mouth.setAttribute('stroke-linecap', 'round');
            svg.appendChild(mouth);

            // Right side of mouth
            const mouthR = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            mouthR.setAttribute('d', 'M 100 110 Q 105 115 110 113');
            mouthR.setAttribute('stroke', '#ff69b4'); // Pink
            mouthR.setAttribute('stroke-width', '2');
            mouthR.setAttribute('fill', 'none');
            mouthR.setAttribute('stroke-linecap', 'round');
            svg.appendChild(mouthR);

            // Whiskers (add back for more cat-like appearance)
            const whiskerL1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerL1.setAttribute('x1', '60');
            whiskerL1.setAttribute('y1', '100');
            whiskerL1.setAttribute('x2', '85');
            whiskerL1.setAttribute('y2', '102');
            whiskerL1.setAttribute('stroke', 'rgba(255,255,255,0.6)');
            whiskerL1.setAttribute('stroke-width', '2');
            whiskerL1.setAttribute('stroke-linecap', 'round');
            svg.appendChild(whiskerL1);

            const whiskerL2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerL2.setAttribute('x1', '60');
            whiskerL2.setAttribute('y1', '105');
            whiskerL2.setAttribute('x2', '85');
            whiskerL2.setAttribute('y2', '105');
            whiskerL2.setAttribute('stroke', 'rgba(255,255,255,0.6)');
            whiskerL2.setAttribute('stroke-width', '2');
            whiskerL2.setAttribute('stroke-linecap', 'round');
            svg.appendChild(whiskerL2);

            const whiskerL3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerL3.setAttribute('x1', '60');
            whiskerL3.setAttribute('y1', '110');
            whiskerL3.setAttribute('x2', '85');
            whiskerL3.setAttribute('y2', '108');
            whiskerL3.setAttribute('stroke', 'rgba(255,255,255,0.6)');
            whiskerL3.setAttribute('stroke-width', '2');
            whiskerL3.setAttribute('stroke-linecap', 'round');
            svg.appendChild(whiskerL3);

            const whiskerR1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerR1.setAttribute('x1', '140');
            whiskerR1.setAttribute('y1', '102');
            whiskerR1.setAttribute('x2', '115');
            whiskerR1.setAttribute('y2', '100');
            whiskerR1.setAttribute('stroke', 'rgba(255,255,255,0.6)');
            whiskerR1.setAttribute('stroke-width', '2');
            whiskerR1.setAttribute('stroke-linecap', 'round');
            svg.appendChild(whiskerR1);

            const whiskerR2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerR2.setAttribute('x1', '140');
            whiskerR2.setAttribute('y1', '105');
            whiskerR2.setAttribute('x2', '115');
            whiskerR2.setAttribute('y2', '105');
            whiskerR2.setAttribute('stroke', 'rgba(255,255,255,0.6)');
            whiskerR2.setAttribute('stroke-width', '2');
            whiskerR2.setAttribute('stroke-linecap', 'round');
            svg.appendChild(whiskerR2);

            const whiskerR3 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            whiskerR3.setAttribute('x1', '140');
            whiskerR3.setAttribute('y1', '108');
            whiskerR3.setAttribute('x2', '115');
            whiskerR3.setAttribute('y2', '110');
            whiskerR3.setAttribute('stroke', 'rgba(255,255,255,0.6)');
            whiskerR3.setAttribute('stroke-width', '2');
            whiskerR3.setAttribute('stroke-linecap', 'round');
            svg.appendChild(whiskerR3);

            // Front left paw (small rounded shape at bottom - gradient)
            const pawFL = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            pawFL.setAttribute('cx', '75');
            pawFL.setAttribute('cy', '170');
            pawFL.setAttribute('rx', '10');
            pawFL.setAttribute('ry', '8');
            pawFL.setAttribute('fill', 'url(#bodyGradient)');
            svg.appendChild(pawFL);

            // Front right paw (small rounded shape at bottom - gradient)
            const pawFR = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
            pawFR.setAttribute('cx', '125');
            pawFR.setAttribute('cy', '170');
            pawFR.setAttribute('rx', '10');
            pawFR.setAttribute('ry', '8');
            pawFR.setAttribute('fill', 'url(#bodyGradient)');
            svg.appendChild(pawFR);

            // Tail (long thin C-shaped, gradient)
            const tail = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            tail.setAttribute('d', 'M 50 130 Q 30 100 20 70 Q 15 50 25 45');
            tail.setAttribute('stroke', 'url(#bodyGradient)');
            tail.setAttribute('stroke-width', '8');
            tail.setAttribute('fill', 'none');
            tail.setAttribute('stroke-linecap', 'round');
            tail.setAttribute('class', 'cat-tail');
            svg.appendChild(tail);

            catContainer.appendChild(svg);

            // Store references for animations
            window.cat2D = {
                body,
                head,
                eyeL,
                eyeR,
                pupilL,
                pupilR,
                earL,
                earR,
                tail,
                pawFL,
                pawFR,
                svg,
                catContainer
            };

            // Mouse interaction state
            let mouseX = 100; // Center of cat (viewBox coordinates)
            let mouseY = 100;
            let lastMouseMove = Date.now();
            let autonomousMode = true;
            let lookAtTarget = { x: 100, y: 100 };
            let currentEyeOffset = { x: 0, y: 0 };

            // Initialize animations
            if (typeof gsap !== 'undefined') {
                // Idle breathing animation (affects body and head)
                gsap.to(body, {
                    attr: { ry: 52 },
                    duration: 1.5,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
                gsap.to(head, {
                    attr: { ry: 42 },
                    duration: 1.5,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });

                // Tail sway
                gsap.to(tail, {
                    rotation: 15,
                    transformOrigin: "55 120",
                    duration: 2,
                    repeat: -1,
                    yoyo: true,
                    ease: "sine.inOut"
                });

                // Blink animation (oval eyes close vertically)
                function blink() {
                    gsap.to([eyeL, eyeR], {
                        attr: { ry: 1 },
                        duration: 0.15,
                        yoyo: true,
                        repeat: 1,
                        onComplete: () => {
                            setTimeout(blink, Math.random() * 3000 + 2000);
                        }
                    });
                }
                blink();
            }

            // Roll animation function
            window.doCatRoll = function(direction = 1) {
                if (typeof gsap === 'undefined') return;
                const rollSequence = gsap.timeline();
                
                rollSequence.to(svg, {
                    rotation: direction * 360,
                    transformOrigin: "50% 50%",
                    duration: 0.6,
                    ease: "power2.inOut"
                });
                rollSequence.to(body, {
                    attr: { cy: 140 },
                    duration: 0.15,
                    yoyo: true,
                    repeat: 1,
                    ease: "power2.out"
                }, 0);
            };

            // Dance animation
            window.catDance = function() {
                if (typeof gsap === 'undefined') return;
                gsap.to(svg, {
                    rotation: 10,
                    transformOrigin: "50% 50%",
                    duration: 0.3,
                    repeat: 1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
                gsap.to(body, {
                    attr: { cy: 115 },
                    duration: 0.3,
                    repeat: 1,
                    yoyo: true,
                    ease: "sine.inOut"
                });
            };

            // Eye following mouse function
            function updateEyeLook() {
                if (!eyeL || !eyeR || !pupilL || !pupilR) return;

                const catRect = catContainer.getBoundingClientRect();
                const catCenterX = catRect.left + catRect.width / 2;
                const catCenterY = catRect.top + catRect.height / 2;
                
                // Convert mouse position to SVG coordinates
                const svgMouseX = ((mouseX - catCenterX) / catRect.width) * 200;
                const svgMouseY = ((mouseY - catCenterY) / catRect.height) * 200;
                
                // Calculate eye offset (limit to eye radius)
                const maxOffset = 2.5;
                const eyeLX = 88; // Left eye center X
                const eyeLY = 90; // Left eye center Y
                const eyeRX = 112; // Right eye center X
                const eyeRY = 90; // Right eye center Y
                
                const distL = Math.sqrt(Math.pow(svgMouseX - eyeLX, 2) + Math.pow(svgMouseY - eyeLY, 2));
                const distR = Math.sqrt(Math.pow(svgMouseX - eyeRX, 2) + Math.pow(svgMouseY - eyeRY, 2));
                
                const offsetL = Math.min(distL / 20, 1) * maxOffset;
                const offsetR = Math.min(distR / 20, 1) * maxOffset;
                
                const angleL = Math.atan2(svgMouseY - eyeLY, svgMouseX - eyeLX);
                const angleR = Math.atan2(svgMouseY - eyeRY, svgMouseX - eyeRX);
                
                const offsetXL = Math.cos(angleL) * offsetL;
                const offsetYL = Math.sin(angleL) * offsetL;
                const offsetXR = Math.cos(angleR) * offsetR;
                const offsetYR = Math.sin(angleR) * offsetR;
                
                // Smooth eye and pupil movement
                if (typeof gsap !== 'undefined') {
                    gsap.to(eyeL, {
                        attr: { cx: eyeLX + offsetXL, cy: eyeLY + offsetYL },
                        duration: 0.3,
                        ease: "power2.out"
                    });
                    gsap.to(eyeR, {
                        attr: { cx: eyeRX + offsetXR, cy: eyeRY + offsetYR },
                        duration: 0.3,
                        ease: "power2.out"
                    });
                    gsap.to(pupilL, {
                        attr: { cx: eyeLX + offsetXL, cy: eyeLY + offsetYL },
                        duration: 0.3,
                        ease: "power2.out"
                    });
                    gsap.to(pupilR, {
                        attr: { cx: eyeRX + offsetXR, cy: eyeRY + offsetYR },
                        duration: 0.3,
                        ease: "power2.out"
                    });
                }
            }

            // Autonomous eye movement when mouse is idle
            function autonomousEyeMovement() {
                if (Date.now() - lastMouseMove > 3000) {
                    // Mouse hasn't moved in 3 seconds - look around autonomously
                    const catRect = catContainer.getBoundingClientRect();
                    const randomX = catRect.left + catRect.width / 2 + (Math.random() - 0.5) * 100;
                    const randomY = catRect.top + catRect.height / 2 + (Math.random() - 0.5) * 100;
                    
                    if (typeof gsap !== 'undefined') {
                        gsap.to({}, {
                            duration: 1,
                            onUpdate: function() {
                                const t = this.progress();
                                mouseX = catRect.left + catRect.width / 2 + (randomX - catRect.left - catRect.width / 2) * t;
                                mouseY = catRect.top + catRect.height / 2 + (randomY - catRect.top - catRect.height / 2) * t;
                                updateEyeLook();
                            }
                        });
                    }
                }
            }

            // Cat reacts to mouse proximity
            function reactToMouse() {
                const catRect = catContainer.getBoundingClientRect();
                const catCenterX = catRect.left + catRect.width / 2;
                const catCenterY = catRect.top + catRect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(mouseX - catCenterX, 2) + 
                    Math.pow(mouseY - catCenterY, 2)
                );
                
                // Always update eye look when mouse moves
                updateEyeLook();
                
                // If mouse is close (within 150px), cat reacts
                if (distance < 150 && distance > 50) {
                    // Cat is interested - ear twitch occasionally
                    if (typeof gsap !== 'undefined' && Math.random() < 0.05) {
                        gsap.to([earL, earR], {
                            rotation: 5,
                            transformOrigin: "50% 100%",
                            duration: 0.2,
                            yoyo: true,
                            repeat: 1,
                            ease: "sine.inOut"
                        });
                    }
                } else if (distance < 50) {
                    // Mouse very close - cat gets excited
                    if (typeof gsap !== 'undefined' && Math.random() < 0.1) {
                        gsap.to(body, {
                            attr: { r: 52 },
                            duration: 0.2,
                            yoyo: true,
                            repeat: 1,
                            ease: "power2.out"
                        });
                    }
                }
            }

            // Global mouse tracking - cat always watches the mouse
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
                lastMouseMove = Date.now();
                reactToMouse();
            });

            // Update eye look periodically
            setInterval(() => {
                if (Date.now() - lastMouseMove < 3000) {
                    updateEyeLook();
                } else {
                    autonomousEyeMovement();
                }
            }, 100);

            // Autonomous wandering when mouse is idle
            let wanderTarget = { x: 100, y: 100 };
            setInterval(() => {
                if (Date.now() - lastMouseMove > 5000) {
                    // Mouse idle for 5+ seconds - cat wanders
                    const catRect = catContainer.getBoundingClientRect();
                    const maxWander = 30;
                    wanderTarget.x = 100 + (Math.random() - 0.5) * maxWander;
                    wanderTarget.y = 100 + (Math.random() - 0.5) * maxWander;
                    
                    if (typeof gsap !== 'undefined') {
                        gsap.to({}, {
                            duration: 2,
                            onUpdate: function() {
                                const t = this.progress();
                                const currentX = 100 + (wanderTarget.x - 100) * t;
                                const currentY = 100 + (wanderTarget.y - 100) * t;
                                
                                // Convert to screen coordinates for eye tracking
                                const catRect = catContainer.getBoundingClientRect();
                                mouseX = catRect.left + (currentX / 200) * catRect.width;
                                mouseY = catRect.top + (currentY / 200) * catRect.height;
                                updateEyeLook();
                            }
                        });
                    }
                }
            }, 3000);
        }
        
        // Start initialization - wait for Alpine.js and libraries
        function startCatInit() {
            // Wait for Alpine.js to be ready
            if (typeof Alpine === 'undefined') {
                setTimeout(startCatInit, 100);
                return;
            }

            // Wait for Alpine to initialize the component
            Alpine.nextTick(() => {
                // Give it a bit more time for the element to be created
                setTimeout(() => {
                    init2DCat();
                }, 300);
            });
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startCatInit);
        } else {
            startCatInit();
        }

    </script>
</body>
</html>
