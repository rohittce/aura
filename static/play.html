<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AURA // Music Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- PWA -->
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#6366f1">
    <link rel="apple-touch-icon" href="https://img.icons8.com/clouds/100/cat.png">
    <script src="/static/shared-app.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.4/socket.io.min.js"></script>
    <!-- Three.js for 3D Cat -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        @keyframes float {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            33% {
                transform: translate(2vw, -5vh) rotate(2deg);
            }

            66% {
                transform: translate(-1vw, 3vh) rotate(-1deg);
            }
        }

        .animate-aura {
            animation: float 18s infinite ease-in-out;
        }

        @keyframes pulse-bar {

            0%,
            100% {
                height: 20%;
                opacity: 0.5;
            }

            50% {
                height: 80%;
                opacity: 1;
            }
        }

        .playing .bar-anim {
            animation: pulse-bar 1s infinite ease-in-out;
        }

        .glass {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .glass-hover:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .progress-bar {
            transition: width 0.1s linear;
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hide YouTube iframe but keep it functional */
        #youtube-player {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        /* 3D Cat Container */
        .cat-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            z-index: 50;
            cursor: pointer;
            transition: transform 0.3s ease, bottom 0.3s ease, right 0.3s ease;
            will-change: transform;
            user-select: none;
            -webkit-user-select: none;
            overflow: visible;
            /* No border, background, or shadow - clean cat only */
        }

        .cat-container:hover {
            transform: scale(1.05);
        }

        .cat-container.following {
            transition: transform 0.1s ease, bottom 0.1s ease, right 0.1s ease;
        }

        .cat-container svg {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        .cat-svg {
            overflow: visible;
        }

        .cat-container.rolling-around {
            animation: catRollAround 3s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            will-change: transform;
        }

        @keyframes catRollAround {
            0% {
                transform: rotate(0deg) translateX(0) translateY(0) scale(1);
            }

            12.5% {
                transform: rotate(45deg) translateX(20px) translateY(-15px) scale(0.98);
            }

            25% {
                transform: rotate(90deg) translateX(35px) translateY(-30px) scale(0.96);
            }

            37.5% {
                transform: rotate(135deg) translateX(20px) translateY(-40px) scale(0.94);
            }

            50% {
                transform: rotate(180deg) translateX(0) translateY(-45px) scale(0.92);
            }

            62.5% {
                transform: rotate(225deg) translateX(-20px) translateY(-40px) scale(0.94);
            }

            75% {
                transform: rotate(270deg) translateX(-35px) translateY(-30px) scale(0.96);
            }

            87.5% {
                transform: rotate(315deg) translateX(-20px) translateY(-15px) scale(0.98);
            }

            100% {
                transform: rotate(360deg) translateX(0) translateY(0) scale(1);
            }
        }

        .cat-svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
        }

        /* Cat Idle Animation */
        @keyframes catIdle {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-5px) rotate(2deg);
            }
        }

        .cat-idle {
            animation: catIdle 3s ease-in-out infinite;
        }

        /* Cat Dancing Animation */
        @keyframes catDance {

            0%,
            100% {
                transform: translateY(0) rotate(-5deg) scale(1);
            }

            25% {
                transform: translateY(-10px) rotate(5deg) scale(1.05);
            }

            50% {
                transform: translateY(-5px) rotate(-5deg) scale(1);
            }

            75% {
                transform: translateY(-10px) rotate(5deg) scale(1.05);
            }
        }

        .cat-dancing {
            animation: catDance 0.6s ease-in-out infinite;
        }

        /* Cat Happy Animation */
        @keyframes catHappy {

            0%,
            100% {
                transform: translateY(0) rotate(0deg) scale(1);
            }

            25% {
                transform: translateY(-8px) rotate(-3deg) scale(1.1);
            }

            50% {
                transform: translateY(-12px) rotate(3deg) scale(1.15);
            }

            75% {
                transform: translateY(-8px) rotate(-3deg) scale(1.1);
            }
        }

        .cat-happy {
            animation: catHappy 1s ease-in-out infinite;
        }

        /* Cat Sad Animation */
        @keyframes catSad {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(3px) rotate(-2deg);
            }
        }

        .cat-sad {
            animation: catSad 2s ease-in-out infinite;
            opacity: 0.7;
        }

        /* Cat Depressed Animation */
        @keyframes catDepressed {

            0%,
            100% {
                transform: translateY(5px) rotate(-1deg);
            }

            50% {
                transform: translateY(8px) rotate(1deg);
            }
        }

        .cat-depressed {
            animation: catDepressed 3s ease-in-out infinite;
            opacity: 0.5;
            filter: grayscale(0.3);
        }

        /* Cat Excited Animation */
        @keyframes catExcited {

            0%,
            100% {
                transform: translateY(0) rotate(0deg) scale(1);
            }

            33% {
                transform: translateY(-15px) rotate(-10deg) scale(1.2);
            }

            66% {
                transform: translateY(-15px) rotate(10deg) scale(1.2);
            }
        }

        .cat-excited {
            animation: catExcited 0.4s ease-in-out infinite;
        }

        /* Cat Sleeping Animation */
        @keyframes catSleep {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(2px) rotate(1deg);
            }
        }

        .cat-sleeping {
            animation: catSleep 3s ease-in-out infinite;
            opacity: 0.6;
        }

        /* Cat Tail Animation */
        @keyframes tailWag {

            0%,
            100% {
                transform: rotate(-10deg);
            }

            50% {
                transform: rotate(10deg);
            }
        }

        .cat-playing .cat-tail {
            animation: tailWag 0.5s ease-in-out infinite;
            transform-origin: 20px 15px;
        }

        /* Cat Ears Animation */
        @keyframes earTwitch {

            0%,
            100% {
                transform: rotate(0deg);
            }

            50% {
                transform: rotate(-5deg);
            }
        }

        .cat-listening .cat-ear {
            animation: earTwitch 2s ease-in-out infinite;
            transition: all 0.5s ease;
        }

        /* Animations */
        @keyframes cat-float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes cat-dance {

            0%,
            100% {
                transform: rotate(-5deg) translateY(0);
            }

            50% {
                transform: rotate(5deg) translateY(-8px);
            }
        }

        @keyframes blink {

            0%,
            90%,
            100% {
                transform: scaleY(1);
            }

            95% {
                transform: scaleY(0.1);
            }
        }

        .cat-dancing .cat-wrapper {
            animation: cat-dance 0.6s ease-in-out infinite;
        }

        .cat-idle .cat-wrapper {
            animation: cat-float 3s ease-in-out infinite;
        }

        .cat-eye {
            transform-origin: center;
            animation: blink 4s infinite;
        }

        .cat-body {
            fill: url(#catGradient);
            transition: fill 0.5s ease;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.5));
        }

        .cat-inner-ear {
            fill: #fca5a1;
            opacity: 0.6;
        }

        .cat-fur-accent {
            fill: rgba(255, 255, 255, 0.05);
        }

        .cat-accent {
            fill: #818cf8;
        }

        .glow .cat-body {
            fill: url(#catGlowGradient);
            filter: drop-shadow(0 0 15px rgba(129, 140, 248, 0.8)) drop-shadow(0 0 30px rgba(129, 140, 248, 0.4));
        }

        .cat-speech {
            position: absolute;
            top: -60px;
            right: 0;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 8px 16px;
            border-radius: 20px 20px 20px 0;
            font-size: 14px;
            color: white;
            white-space: nowrap;
            opacity: 0;
            transform: scale(0.5) translateY(20px);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            pointer-events: none;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .cat-speech.show {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        .cat-speech::after {
            content: '';
            position: absolute;
            bottom: -6px;
            right: 20px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid rgba(0, 0, 0, 0.8);
        }

        /* Cat Heart Particles */
        @keyframes heartFloat {
            0% {
                transform: translateY(0) scale(0) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .cat-heart {
            position: absolute;
            font-size: 24px;
            animation: heartFloat 1.5s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        /* Cat Star Particles */
        @keyframes starFloat {
            0% {
                transform: translateY(0) scale(0) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: translateY(-60px) scale(1.2) rotate(720deg);
                opacity: 0;
            }
        }

        .cat-star {
            position: absolute;
            font-size: 20px;
            animation: starFloat 2s ease-out forwards;
            pointer-events: none;
            z-index: 100;
        }

        /* Cat Sparkle Effect */
        @keyframes sparkle {

            0%,
            100% {
                opacity: 0;
                transform: scale(0);
            }

            50% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .cat-sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            animation: sparkle 0.6s ease-in-out infinite;
            pointer-events: none;
        }

        /* Cat Glow Effect */
        .cat-container.glow {
            filter: drop-shadow(0 0 20px rgba(139, 92, 246, 0.8)) drop-shadow(0 0 40px rgba(167, 139, 250, 0.6));
        }

        /* Cat Bounce Effect */
        @keyframes catBounce {

            0%,
            100% {
                transform: translateY(0) scale(1);
            }

            50% {
                transform: translateY(-30px) scale(1.1);
            }
        }

        .cat-container.bouncing {
            animation: catBounce 0.6s ease-in-out;
        }

        /* Cat Spin Effect */
        @keyframes catSpin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .cat-container.spinning {
            animation: catSpin 0.8s ease-in-out;
        }

        /* Musical Notes Particles */
        @keyframes noteFloat {
            0% {
                transform: translateY(0) translateX(0) rotate(0deg) scale(0);
                opacity: 1;
            }

            50% {
                opacity: 1;
            }

            100% {
                transform: translateY(-80px) translateX(30px) rotate(360deg) scale(1.5);
                opacity: 0;
            }
        }

        .cat-note {
            position: absolute;
            font-size: 18px;
            animation: noteFloat 2s ease-out forwards;
            pointer-events: none;
            z-index: 100;
            text-shadow: 0 0 10px currentColor;
        }

        /* Rainbow Dancing Aura */
        @keyframes rainbowAura {
            0% {
                box-shadow: 0 0 20px #ff6b6b, 0 0 40px #ff6b6b40;
            }

            16% {
                box-shadow: 0 0 20px #feca57, 0 0 40px #feca5740;
            }

            33% {
                box-shadow: 0 0 20px #48dbfb, 0 0 40px #48dbfb40;
            }

            50% {
                box-shadow: 0 0 20px #ff9ff3, 0 0 40px #ff9ff340;
            }

            66% {
                box-shadow: 0 0 20px #54a0ff, 0 0 40px #54a0ff40;
            }

            83% {
                box-shadow: 0 0 20px #5f27cd, 0 0 40px #5f27cd40;
            }

            100% {
                box-shadow: 0 0 20px #ff6b6b, 0 0 40px #ff6b6b40;
            }
        }

        .cat-dancing .cat-wrapper {
            animation: cat-dance 0.6s ease-in-out infinite, rainbowAura 2s linear infinite;
            border-radius: 50%;
        }

        /* Pulsing Aura Effect */
        @keyframes pulseAura {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.7);
            }

            50% {
                box-shadow: 0 0 0 15px rgba(139, 92, 246, 0);
            }
        }

        .cat-container.pulsing {
            animation: pulseAura 1s ease-in-out infinite;
        }

        /* Purring Effect */
        @keyframes purr {

            0%,
            100% {
                transform: scale(1);
            }

            25% {
                transform: scale(1.02);
            }

            50% {
                transform: scale(0.98);
            }

            75% {
                transform: scale(1.02);
            }
        }

        .cat-purring .cat-wrapper {
            animation: purr 0.3s ease-in-out infinite;
        }

        /* Cat Nap (Zzz) */
        @keyframes zzzFloat {
            0% {
                transform: translateY(0) translateX(0) scale(0.5);
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            100% {
                transform: translateY(-50px) translateX(20px) scale(1.5);
                opacity: 0;
            }
        }

        .cat-zzz {
            position: absolute;
            font-size: 16px;
            color: rgba(255, 255, 255, 0.6);
            animation: zzzFloat 3s ease-out forwards;
            pointer-events: none;
        }

        /* Cat Ears Dancing */
        @keyframes earBop {

            0%,
            100% {
                transform: rotate(-5deg);
            }

            50% {
                transform: rotate(10deg);
            }
        }

        .cat-dancing .cat-ear-left {
            animation: earBop 0.3s ease-in-out infinite;
            transform-origin: center bottom;
        }

        .cat-dancing .cat-ear-right {
            animation: earBop 0.3s ease-in-out infinite 0.15s;
            transform-origin: center bottom;
        }

        /* Vibing Cat Head Bob */
        @keyframes headBob {

            0%,
            100% {
                transform: translateY(0) rotate(0deg);
            }

            25% {
                transform: translateY(-3px) rotate(-3deg);
            }

            75% {
                transform: translateY(-3px) rotate(3deg);
            }
        }

        .cat-vibing .cat-head {
            animation: headBob 0.4s ease-in-out infinite;
        }

        /* Love Eyes */
        .cat-love .cat-pupil {
            fill: #ff6b6b !important;
            filter: drop-shadow(0 0 4px #ff6b6b);
        }

        /* Sparkle Eyes */
        @keyframes sparkleEye {

            0%,
            100% {
                filter: brightness(1);
            }

            50% {
                filter: brightness(1.5) drop-shadow(0 0 3px #fff);
            }
        }

        .cat-excited .cat-eye {
            animation: sparkleEye 0.5s ease-in-out infinite;
        }


        /* Toast Notification System */
        .toast-container {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-width: 350px;
        }

        .toast {
            background: rgba(20, 20, 25, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 14px 18px;
            display: flex;
            align-items: center;
            gap: 12px;
            animation: toastSlideIn 0.3s ease-out;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }

        .toast.toast-exit {
            animation: toastSlideOut 0.3s ease-in forwards;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .toast-content {
            flex: 1;
        }

        .toast-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .toast-message {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .toast-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            padding: 4px;
            font-size: 16px;
            transition: color 0.2s;
        }

        .toast-close:hover {
            color: white;
        }

        .toast.toast-info {
            border-left: 3px solid #6366f1;
        }

        .toast.toast-success {
            border-left: 3px solid #22c55e;
        }

        .toast.toast-warning {
            border-left: 3px solid #f59e0b;
        }

        .toast.toast-error {
            border-left: 3px solid #ef4444;
        }

        /* Song Queue Status Indicators */
        .song-ready {
            position: relative;
        }

        .song-ready::after {
            content: 'âœ“';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 16px;
            height: 16px;
            background: #22c55e;
            border-radius: 50%;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .song-loading::after {
            content: '';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 14px;
            height: 14px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #6366f1;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* Mobile 2D Avatar Fallback */
        .mobile-cat-avatar {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 30% 30%, #4b5563, #1f2937);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
            display: none;
            /* Hidden by default */
        }

        .mobile-cat-avatar.visible {
            display: block;
        }

        .mobile-cat-ears {
            position: absolute;
            top: -20px;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
        }

        .mobile-cat-ear {
            width: 20px;
            height: 30px;
            background: #1f2937;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }

        .mobile-cat-eyes {
            position: absolute;
            top: 40%;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 30px;
        }

        .mobile-cat-eye {
            width: 10px;
            height: 15px;
            background: #fbbf24;
            border-radius: 50%;
            animation: blink 3s infinite;
        }

        @keyframes mobileBeat {
            from {
                transform: scale(1);
            }

            to {
                transform: scale(1.05);
            }
        }

        /* Mobile Bottom Nav */
        .mobile-bottom-nav {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 80px;
            background: rgba(10, 10, 15, 0.8);
            backdrop-filter: blur(25px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .mobile-mode .mobile-bottom-nav {
            display: flex;
            align-items: center;
            justify-content: space-around;
        }

        .mobile-mode .md-only {
            display: none !important;
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            color: rgba(255, 255, 255, 0.5);
            transition: all 0.3s ease;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            width: 33.33%;
        }

        .nav-item.active {
            color: #818cf8;
        }

        .nav-item svg {
            width: 24px;
            height: 24px;
        }

        /* Adjust main padding for bottom nav */
        .mobile-mode main {
            padding-bottom: 100px;
        }

        /* Hide specific elements on mobile */
        .mobile-mode .mobile-hidden {
            display: none !important;
        }

        /* Chat Styles */
        .chat-msg {
            max-width: 85%;
            margin-bottom: 8px;
            padding: 8px 12px;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 13px;
        }

        .chat-msg-own {
            background: rgba(99, 102, 241, 0.2);
            align-self: flex-end;
            margin-left: auto;
        }

        .chat-username {
            font-weight: bold;
            font-size: 11px;
            color: #818cf8;
            margin-bottom: 2px;
        }
    </style>
</head>

<body class="bg-[#020202] text-white overflow-hidden" x-data="playApp()" x-init="init()">
    <!-- Unified Navigation -->
    <nav class="relative z-[100] flex items-center justify-between px-6 md:px-10 py-6 md:py-8">
        <div class="flex items-center space-x-6">
            <a href="/" class="flex items-center space-x-2 group">
                <div
                    class="w-8 h-8 bg-gradient-to-tr from-indigo-500 to-rose-500 rounded-lg rotate-12 group-hover:rotate-45 transition-transform">
                </div>
                <span class="text-2xl font-black tracking-tighter">AURA.</span>
            </a>

            <div
                class="hidden md:flex items-center space-x-6 text-[10px] uppercase font-bold tracking-[0.2em] text-gray-400">
                <a href="/app#seed" class="hover:text-white transition-all">DNA</a>
                <a href="/app#recommendations" class="hover:text-white transition-all">Discovery</a>
                <a href="/play" class="text-white">Player</a>
            </div>
        </div>

        <div class="flex items-center space-x-4">
            <template x-if="authToken">
                <div class="flex items-center space-x-4">
                    <div class="hidden sm:flex flex-col items-end">
                        <span class="text-xs font-bold" x-text="username || 'User'"></span>
                        <span class="text-[10px] text-gray-500" x-text="userEmail"></span>
                    </div>
                    <button @click="friendRoom.isOpen = true"
                        class="w-10 h-10 rounded-full glass border-2 border-white/10 overflow-hidden hover:scale-105 transition-transform">
                        <img :src="`https://api.dicebear.com/7.x/avataaars/svg?seed=${username || userId}`"
                            class="w-full h-full object-cover">
                    </button>
                    <button @click="handleLogout()"
                        class="glass p-2 rounded-lg hover:bg-red-500/20 text-gray-400 hover:text-red-400 transition-all">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                        </svg>
                    </button>
                </div>
            </template>
            <template x-if="!authToken">
                <a href="/login"
                    class="px-6 py-2 glass rounded-full text-xs font-bold hover:bg-white hover:text-black transition-all">Sign
                    In</a>
            </template>
        </div>
    </nav>

    <!-- SharedApp handles Toasts -->
    <!-- Hidden audio for background playback persistence -->
    <audio id="bg-persistence-audio" loop style="display: none;"
        src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=="></audio>

    <!-- YouTube IFrame API -->
    <div id="youtube-player"></div>
    <!-- Client-side Ad Blocker -->
    <script src="/static/ad-blocker.js"></script>
    <script src="https://www.youtube.com/iframe_api"></script>

    <!-- GSAP for 2D Cat Animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <div class="fixed inset-0 z-0">
        <div
            class="absolute top-[-20%] left-[-10%] w-[70vw] h-[70vw] bg-purple-600/20 rounded-full blur-[120px] animate-aura">
        </div>
        <div class="absolute bottom-[-10%] right-[-10%] w-[60vw] h-[60vw] bg-blue-600/15 rounded-full blur-[120px] animate-aura"
            style="animation-delay: -9s;"></div>
    </div>

    <!-- Aesthetic 2D Interactive Cat -->
    <div class="cat-container" x-data="catEmotion()" x-show="!friendRoom.isOpen && !searchModal"
        :class="[playing ? 'cat-dancing' : 'cat-idle', isGlowing ? 'glow' : '']"
        :style="`bottom: ${catY}px; right: ${catX}px;`" @click="interactWithCat()" @mouseenter="showSpeech('Meow! ðŸ±')"
        @mouseleave="hideSpeech()" @mousedown="startDrag($event)" @touchstart.passive="startDrag($event)"
        @touchmove.prevent="handleDrag($event)" @touchend="stopDrag()">

        <div class="cat-speech" :class="{ 'show': speechVisible }" x-text="speechText"></div>

        <div class="cat-wrapper">
            <svg viewBox="0 0 200 200" class="cat-svg">
                <defs>
                    <linearGradient id="catGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#2d3748;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#1a202c;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="catGlowGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#4338ca;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#312e81;stop-opacity:1" />
                    </linearGradient>
                </defs>

                <!-- Tail with organic curve -->
                <path class="cat-body" d="M160,130 C195,130 200,180 170,195 C155,202 140,190 145,175" fill="none"
                    stroke-width="14" stroke-linecap="round" />

                <!-- Body - More organic shape -->
                <path class="cat-body"
                    d="M100,45 C145,45 165,85 165,135 C165,175 145,195 100,195 C55,195 35,175 35,135 C35,85 55,45 100,45" />

                <!-- Cheek Fur Accents -->
                <path class="cat-fur-accent" d="M40,140 Q30,150 40,160 Z" />
                <path class="cat-fur-accent" d="M160,140 Q170,150 160,160 Z" />

                <!-- Ears - More detailed -->
                <g class="cat-ear-left">
                    <path class="cat-body" d="M65,65 Q35,10 85,55 Z" />
                    <path class="cat-inner-ear" d="M60,60 Q45,30 75,55 Z" />
                </g>
                <g class="cat-ear-right">
                    <path class="cat-body" d="M135,65 Q165,10 115,55 Z" />
                    <path class="cat-inner-ear" d="M140,60 Q155,30 125,55 Z" />
                </g>

                <!-- Chest Fur Accent -->
                <path class="cat-fur-accent" d="M100,150 Q80,170 100,185 Q120,170 100,150 Z" />

                <!-- Eyes Container -->
                <g :style="`transform: translate(${eyeOffsetX}px, ${eyeOffsetY}px)`">
                    <!-- Left Eye -->
                    <g class="cat-eye">
                        <ellipse cx="78" cy="115" rx="14" ry="16" fill="white" />
                        <ellipse cx="78" cy="115" rx="7" ry="12" fill="#000" class="cat-pupil" />
                        <circle cx="82" cy="108" r="3" fill="white" opacity="0.8" />
                    </g>
                    <!-- Right Eye -->
                    <g class="cat-eye">
                        <ellipse cx="122" cy="115" rx="14" ry="16" fill="white" />
                        <ellipse cx="122" cy="115" rx="7" ry="12" fill="#000" class="cat-pupil" />
                        <circle cx="126" cy="108" r="3" fill="white" opacity="0.8" />
                    </g>
                </g>

                <!-- Nose - More detailed shape -->
                <path d="M96,128 Q100,132 104,128 Q100,134 96,128 Z" fill="#ffb7b7" />

                <!-- Mouth -->
                <path d="M92,142 Q100,148 108,142" fill="none" stroke="#ffb7b7" stroke-width="2"
                    stroke-linecap="round" />

                <!-- Whiskers - Thinner and more delicate -->
                <g stroke="rgba(255,255,255,0.3)" stroke-width="1.5">
                    <line x1="55" y1="135" x2="25" y2="130" />
                    <line x1="55" y1="145" x2="25" y2="150" />
                    <line x1="145" y1="135" x2="175" y2="130" />
                    <line x1="145" y1="145" x2="175" y2="150" />
                </g>
            </svg>
        </div>
    </div>

    <div class="relative z-10 h-screen flex flex-col">

        <nav class="flex justify-between items-center p-6 md:p-8">
            <a href="/"
                class="text-2xl font-black tracking-tighter italic hover:opacity-80 transition-opacity">AURA.</a>
            <div class="glass px-4 py-2 rounded-full text-xs font-mono tracking-widest uppercase opacity-70">
                <span x-text="playing ? 'â–¶ Playing' : 'â¸ Paused'"></span>
            </div>
        </nav>

        <main class="flex-1 flex flex-col items-center justify-center px-6 text-center overflow-y-auto pb-32">

            <!-- Album Art -->
            <div class="mb-8 fade-in" x-show="currentSong">
                <div class="w-64 h-64 md:w-80 md:h-80 rounded-2xl overflow-hidden shadow-2xl glass border-2 border-white/10"
                    :class="playing ? 'animate-pulse' : ''">
                    <img :src="currentSong?.song?.image || 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'none\' stroke=\'%23999\'%3E%3Cpath d=\'M9 18V5l12-2v13\'/%3E%3Ccircle cx=\'6\' cy=\'18\' r=\'3\'/%3E%3Ccircle cx=\'18\' cy=\'16\' r=\'3\'/%3E%3C/svg%3E'"
                        :alt="currentSong?.song?.title" class="w-full h-full object-cover">
                </div>
            </div>

            <!-- Song Info -->
            <div class="mb-8 fade-in" x-show="currentSong">
                <h2 class="text-3xl md:text-4xl font-bold mb-2" x-text="currentSong?.song?.title || 'No song selected'">
                </h2>
                <div class="flex flex-wrap items-center justify-center gap-2 mb-1">
                    <p class="text-lg text-gray-400"
                        x-text="currentSong?.song?.artists?.join(', ') || 'Unknown Artist'"></p>
                    <template x-if="friendRoom.currentRoomId">
                        <div
                            class="flex items-center bg-indigo-500/10 border border-indigo-500/30 rounded-full px-3 py-1 ml-2">
                            <span
                                class="text-[10px] font-bold text-indigo-400 mr-2 uppercase tracking-tighter">Room:</span>
                            <span class="text-xs font-mono font-bold text-white tracking-widest"
                                x-text="friendRoom.currentRoomId"></span>
                            <button
                                @click="navigator.clipboard.writeText(friendRoom.currentRoomId); showToast('success', 'Copied', 'Code copied!')"
                                class="ml-2 hover:text-indigo-400 transition-colors">
                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                        d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3" />
                                </svg>
                            </button>
                        </div>
                    </template>
                </div>
                <p class="text-sm text-gray-500" x-text="currentSong?.song?.album || ''"></p>
            </div>

            <!-- Visualizer -->
            <div class="mb-8">
                <div class="flex items-end justify-center space-x-1 h-16 md:h-20" :class="{ 'playing': playing }">
                    <template x-for="i in 20">
                        <div class="w-1 md:w-1.5 bg-gradient-to-t from-indigo-500 to-rose-500 rounded-full bar-anim"
                            :style="`animation-delay: ${i * 0.05}s; height: ${playing ? '100%' : '20%'}`"></div>
                    </template>
                </div>
            </div>

            <!-- Progress Bar -->
            <div class="w-full max-w-md mb-8" x-show="currentSong">
                <div class="flex items-center justify-between text-xs text-gray-500 mb-2">
                    <span x-text="formatTime(currentTime)"></span>
                    <span x-text="formatTime(duration)"></span>
                </div>
                <div class="h-1 bg-white/10 rounded-full overflow-hidden cursor-pointer" @click="seekTo($event)">
                    <div class="h-full bg-gradient-to-r from-indigo-500 to-rose-500 progress-bar"
                        :style="`width: ${progressPercent}%`"></div>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex items-center justify-center space-x-4 mb-8">
                <button @click="previousSong()"
                    class="glass p-3 rounded-full hover:bg-white/10 transition-all active:scale-95"
                    :disabled="recommendations.length === 0">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M12.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0019 16V8a1 1 0 00-1.6-.8l-5.334 4zM4.066 11.2a1 1 0 000 1.6l5.334 4A1 1 0 0011 16V8a1 1 0 00-1.6-.8l-5.334 4z" />
                    </svg>
                </button>

                <button @click="togglePlay()"
                    class="glass p-6 rounded-full hover:bg-white/10 transition-all active:scale-95 relative group">
                    <div
                        class="absolute inset-0 bg-gradient-to-r from-indigo-500 to-rose-500 rounded-full opacity-0 group-hover:opacity-20 transition-opacity">
                    </div>
                    <template x-if="!playing">
                        <svg class="w-8 h-8 fill-white relative z-10" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z" />
                        </svg>
                    </template>
                    <template x-if="playing">
                        <svg class="w-8 h-8 fill-white relative z-10" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
                        </svg>
                    </template>
                </button>

                <button @click="nextSong()"
                    class="glass p-3 rounded-full hover:bg-white/10 transition-all active:scale-95"
                    :disabled="recommendations.length === 0">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M11.933 12.8a1 1 0 000-1.6L6.6 7.2A1 1 0 005 8v8a1 1 0 001.6.8l5.333-4zM19.933 12.8a1 1 0 000-1.6l-5.333-4A1 1 0 0013 8v8a1 1 0 001.6.8l5.333-4z" />
                    </svg>
                </button>
            </div>

            <!-- Explanation -->
            <div class="glass p-6 rounded-2xl max-w-md mb-6" x-show="currentSong?.explanation">
                <p class="text-xs text-gray-400 mb-2 uppercase tracking-widest">Why Recommended</p>
                <p class="text-sm leading-relaxed" x-text="currentSong?.explanation?.text || ''"></p>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-wrap items-center justify-center gap-3">
                <button @click="submitFeedback('like')"
                    class="glass px-6 py-3 rounded-full text-sm hover:bg-rose-500/20 transition-all active:scale-95 flex items-center space-x-2"
                    :disabled="!currentSong">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z" />
                    </svg>
                    <span>Like</span>
                </button>

                <button @click="submitFeedback('skip')"
                    class="glass px-6 py-3 rounded-full text-sm hover:bg-gray-600/20 transition-all active:scale-95 flex items-center space-x-2"
                    :disabled="!currentSong">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M6 18L18 6M6 6l12 12" />
                    </svg>
                    <span>Skip</span>
                </button>

                <button @click="friendRoom.isOpen = true"
                    class="glass px-6 py-3 rounded-full text-sm hover:bg-indigo-500/20 transition-all active:scale-95 flex items-center space-x-2 mobile-hidden">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                    </svg>
                    <span>Social</span>
                    <span x-show="friendRoom.requests.length > 0"
                        class="bg-red-500 text-white text-xs px-1.5 py-0.5 rounded-full"
                        x-text="friendRoom.requests.length"></span>
                </button>

                <button @click="searchModal = true"
                    class="glass px-6 py-3 rounded-full text-sm hover:bg-cyan-500/20 transition-all active:scale-95 flex items-center space-x-2 mobile-hidden">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                    <span>Search Songs</span>
                </button>

                <a :href="currentSong?.platform_links?.spotify" target="_blank"
                    class="glass px-6 py-3 rounded-full text-sm hover:bg-green-500/20 transition-all active:scale-95 flex items-center space-x-2"
                    x-show="currentSong">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path
                            d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.281c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z" />
                    </svg>
                    <span>Open in Spotify</span>
                </a>
            </div>

            <!-- Queue -->
            <div class="mt-8 w-full max-w-2xl" x-show="recommendations.length > 1">
                <p class="text-xs text-gray-500 uppercase tracking-widest mb-4 text-left">Up Next</p>
                <div class="space-y-2 max-h-48 overflow-y-auto">
                    <template x-for="(rec, index) in recommendations.slice(1, 6)" :key="index">
                        <div @click="playSong(rec)"
                            class="glass p-3 rounded-lg cursor-pointer hover:bg-white/5 transition-all flex items-center space-x-3"
                            :class="currentSong?.recommendation_id === rec.recommendation_id ? 'ring-2 ring-indigo-500' : ''">
                            <img :src="rec.song?.image || ''" :alt="rec.song?.title"
                                class="w-12 h-12 rounded object-cover">
                            <div class="flex-1 min-w-0 text-left">
                                <p class="font-medium truncate" x-text="rec.song?.title"></p>
                                <p class="text-xs text-gray-400 truncate" x-text="rec.song?.artists?.join(', ')"></p>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Empty State -->
            <div x-show="!currentSong && !loading" class="text-center py-20">
                <svg class="w-20 h-20 mx-auto mb-4 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                </svg>
                <p class="text-gray-500 mb-2 text-lg">No song selected</p>
                <p class="text-sm text-gray-600 mb-6">Get recommendations to start playing</p>
                <a href="/"
                    class="glass px-6 py-3 rounded-full hover:bg-white hover:text-black transition-all active:scale-95 inline-block">
                    Get Recommendations
                </a>
            </div>
            <!-- Friend & Room Panel Modal -->
            <div x-show="friendRoom.isOpen"
                class="fixed inset-0 z-50 flex items-end md:items-center justify-center p-0 md:p-4 bg-black/60 backdrop-blur-sm"
                x-transition:enter="transition ease-out duration-300"
                x-transition:enter-start="opacity-0 translate-y-full md:translate-y-0"
                x-transition:enter-end="opacity-100 translate-y-0" x-transition:leave="transition ease-in duration-200"
                x-transition:leave-start="opacity-100 translate-y-0"
                x-transition:leave-end="opacity-0 translate-y-full md:translate-y-0" style="display: none;">

                <div class="glass w-full max-w-lg rounded-t-3xl md:rounded-2xl overflow-hidden shadow-2xl bg-black/40 h-[85vh] md:h-auto"
                    @click.away="friendRoom.isOpen = false">
                    <!-- Mobile Drag Handle -->
                    <div class="w-12 h-1.5 bg-white/20 rounded-full mx-auto my-3 md:hidden"></div>
                    <!-- Header -->
                    <div class="p-4 border-b border-white/10 flex justify-between items-center">
                        <h2 class="text-lg font-bold">Social Hub</h2>
                        <button @click="friendRoom.isOpen = false" class="text-gray-400 hover:text-white">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>

                    <!-- Tabs -->
                    <div class="flex border-b border-white/10">
                        <button @click="friendRoom.activeTab = 'friends'"
                            class="flex-1 py-3 text-sm font-medium transition-colors"
                            :class="friendRoom.activeTab === 'friends' ? 'bg-white/10 text-white' : 'text-gray-400 hover:text-gray-200'">Friends</button>
                        <button @click="friendRoom.activeTab = 'rooms'"
                            class="flex-1 py-3 text-sm font-medium transition-colors"
                            :class="friendRoom.activeTab === 'rooms' ? 'bg-white/10 text-white' : 'text-gray-400 hover:text-gray-200'">Rooms</button>
                        <button @click="friendRoom.activeTab = 'chat'"
                            class="flex-1 py-3 text-sm font-medium transition-colors relative"
                            :class="friendRoom.activeTab === 'chat' ? 'bg-white/10 text-white' : 'text-gray-400 hover:text-gray-200'">
                            Chat
                        </button>
                        <button @click="friendRoom.activeTab = 'requests'"
                            class="flex-1 py-3 text-sm font-medium transition-colors relative"
                            :class="friendRoom.activeTab === 'requests' ? 'bg-white/10 text-white' : 'text-gray-400 hover:text-gray-200'">
                            Requests
                            <span x-show="friendRoom.requests.length > 0"
                                class="absolute top-2 right-4 w-2 h-2 bg-red-500 rounded-full"></span>
                        </button>
                    </div>

                    <!-- Content -->
                    <div class="p-6 h-96 overflow-y-auto">

                        <!-- Friends Tab -->
                        <div x-show="friendRoom.activeTab === 'friends'">
                            <!-- Add Friend Search -->
                            <div class="flex space-x-2 mb-6">
                                <input type="text" x-model="friendRoom.searchQuery"
                                    placeholder="Find user by username..."
                                    class="flex-1 glass px-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500">
                                <button @click="sendFriendRequest()"
                                    class="bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded-lg text-sm font-medium transition-colors">Add</button>
                            </div>

                            <!-- List -->
                            <div class="space-y-3">
                                <h3 class="text-xs uppercase text-gray-500 font-bold tracking-wider mb-2">My Friends
                                </h3>
                                <template x-for="friend in friendRoom.friends" :key="friend.user_id">
                                    <div class="flex items-center justify-between glass p-3 rounded-lg">
                                        <div class="flex items-center space-x-3">
                                            <div class="w-8 h-8 rounded-full bg-indigo-500/30 flex items-center justify-center text-sm font-bold"
                                                x-text="friend.username.charAt(0).toUpperCase()"></div>
                                            <div>
                                                <div class="text-sm font-medium" x-text="friend.username"></div>
                                                <div class="text-xs text-green-400" x-text="friend.status || 'Online'">
                                                </div>
                                            </div>
                                        </div>
                                        <div class="flex space-x-2">
                                            <button @click="removeFriend(friend.user_id)"
                                                class="text-gray-400 hover:text-red-400 p-1" title="Remove Friend">
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor"
                                                    viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        stroke-width="2"
                                                        d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </template>
                                <div x-show="friendRoom.friends.length === 0"
                                    class="text-center text-gray-500 text-sm py-4">No friends added yet.</div>
                            </div>
                        </div>


                        <!-- Rooms Tab -->
                        <div x-show="friendRoom.activeTab === 'rooms'">
                            <!-- Join Room by Code -->
                            <div class="mb-6">
                                <h3 class="text-sm font-medium mb-3">Join Room</h3>
                                <div class="flex space-x-2">
                                    <input type="text" x-model="friendRoom.joinCode" placeholder="Enter 6-char code"
                                        maxlength="6"
                                        class="flex-1 glass px-4 py-2 rounded-lg text-sm font-mono uppercase tracking-widest focus:outline-none focus:ring-1 focus:ring-cyan-500"
                                        @input="friendRoom.joinCode = friendRoom.joinCode.toUpperCase()">
                                    <button @click="joinRoomByCode()"
                                        class="bg-cyan-600 hover:bg-cyan-700 px-4 py-2 rounded-lg text-sm font-medium transition-colors">Join</button>
                                </div>
                            </div>

                            <!-- Create Room -->
                            <div class="mb-6">
                                <h3 class="text-sm font-medium mb-3">Create Room</h3>
                                <div class="flex space-x-2">
                                    <input type="text" x-model="friendRoom.newRoomName" placeholder="Room Name"
                                        class="flex-1 glass px-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500">
                                    <button @click="createRoom()"
                                        class="bg-indigo-600 hover:bg-indigo-700 px-4 py-2 rounded-lg text-sm font-medium transition-colors">Create</button>
                                </div>
                            </div>

                            <!-- Current Room Info -->
                            <div x-show="friendRoom.currentRoomId"
                                class="glass p-4 rounded-xl bg-gradient-to-br from-indigo-500/10 to-purple-500/10 border border-indigo-500/20 mb-4">
                                <!-- Header -->
                                <div class="flex items-center justify-between mb-4">
                                    <div>
                                        <h3 class="text-sm font-bold text-indigo-300">Current Room</h3>
                                        <div class="flex items-center space-x-2 mt-1">
                                            <span class="text-2xl font-mono font-bold tracking-wider text-white"
                                                x-text="friendRoom.currentRoomId"></span>
                                            <button
                                                @click="navigator.clipboard.writeText(friendRoom.currentRoomId); showToast('success', 'Copied', 'Room code copied!')"
                                                class="p-1.5 hover:bg-white/10 rounded transition-colors"
                                                title="Copy Code">
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor"
                                                    viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        stroke-width="2"
                                                        d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3" />
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                    <div class="flex items-center space-x-2">
                                        <span x-show="friendRoom.isHost"
                                            class="bg-amber-500/20 text-amber-400 text-[10px] font-bold px-2 py-0.5 rounded-full uppercase">Host</span>
                                        <span
                                            class="bg-green-500/20 text-green-400 text-[10px] font-bold px-2 py-0.5 rounded-full uppercase flex items-center">
                                            <span
                                                class="w-1.5 h-1.5 bg-green-400 rounded-full mr-1 animate-pulse"></span>
                                            Live
                                        </span>
                                    </div>
                                </div>

                                <!-- Participants -->
                                <div class="mb-4">
                                    <h4 class="text-xs uppercase text-gray-400 font-bold tracking-wider mb-2">
                                        Participants (<span x-text="friendRoom.participants.length"></span>)</h4>
                                    <div class="flex flex-wrap gap-2">
                                        <template x-for="p in friendRoom.participants" :key="p.user_id">
                                            <div
                                                class="flex items-center space-x-1.5 bg-white/5 px-2 py-1 rounded-full text-xs">
                                                <div class="w-5 h-5 rounded-full bg-indigo-500/30 flex items-center justify-center text-[10px] font-bold"
                                                    x-text="(p.username || 'U').charAt(0).toUpperCase()"></div>
                                                <span x-text="p.username || 'User'"></span>
                                                <span x-show="p.is_host" class="text-amber-400">ðŸ‘‘</span>
                                            </div>
                                        </template>
                                        <div x-show="friendRoom.participants.length === 0"
                                            class="text-gray-500 text-xs">No participants yet</div>
                                    </div>
                                </div>

                                <!-- Queue (visible to all, editable by host) -->
                                <div class="mb-4" x-show="friendRoom.queue.length > 0">
                                    <h4 class="text-xs uppercase text-gray-400 font-bold tracking-wider mb-2">Up Next
                                    </h4>
                                    <div class="space-y-1 max-h-32 overflow-y-auto">
                                        <template x-for="(song, idx) in friendRoom.queue" :key="idx">
                                            <div
                                                class="flex items-center justify-between bg-white/5 p-2 rounded-lg text-xs">
                                                <div class="flex items-center space-x-2 min-w-0">
                                                    <span class="text-gray-500 w-4" x-text="idx + 1"></span>
                                                    <span class="truncate"
                                                        x-text="song.title || song.song?.title"></span>
                                                </div>
                                                <button x-show="friendRoom.isHost" @click="removeFromQueue(idx)"
                                                    class="text-red-400 hover:text-red-300 p-1 flex-shrink-0">
                                                    <svg class="w-3 h-3" fill="none" stroke="currentColor"
                                                        viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round"
                                                            stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                                    </svg>
                                                </button>
                                            </div>
                                        </template>
                                    </div>
                                </div>

                                <!-- Host Controls -->
                                <div x-show="friendRoom.isHost" class="flex space-x-2 mb-3">
                                    <button @click="nextSong()"
                                        class="flex-1 bg-indigo-500/20 hover:bg-indigo-500/40 text-indigo-300 text-xs py-2 rounded-lg transition-colors flex items-center justify-center space-x-1">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M9 5l7 7-7 7" />
                                        </svg>
                                        <span>Skip</span>
                                    </button>
                                    <button @click="clearQueue()"
                                        class="flex-1 bg-gray-500/20 hover:bg-gray-500/40 text-gray-300 text-xs py-2 rounded-lg transition-colors flex items-center justify-center space-x-1">
                                        <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                                        </svg>
                                        <span>Clear Queue</span>
                                    </button>
                                </div>

                                <!-- Leave Button -->
                                <button @click="leaveRoom()"
                                    class="w-full bg-red-500/20 hover:bg-red-500/40 text-red-200 text-xs py-2 rounded-lg transition-colors">Leave
                                    Room</button>
                            </div>

                            <!-- No Room State -->
                            <div x-show="!friendRoom.currentRoomId" class="text-center py-8 text-gray-500">
                                <svg class="w-12 h-12 mx-auto mb-3 opacity-50" fill="none" stroke="currentColor"
                                    viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"
                                        d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                                </svg>
                                <p class="text-sm">Create or join a room to listen together!</p>
                            </div>
                        </div>

                        <!-- Chat Tab -->
                        <div x-show="friendRoom.activeTab === 'chat'" class="h-full flex flex-col">
                            <template x-if="friendRoom.currentRoomId">
                                <div class="h-full flex flex-col">
                                    <!-- Online Participants -->
                                    <div x-show="friendRoom.participants.length > 0"
                                        class="flex items-center space-x-2 pb-2 mb-2 border-b border-white/10 overflow-x-auto no-scrollbar shrink-0">
                                        <div class="text-[10px] text-gray-500 uppercase tracking-wider font-bold mr-1">
                                            Online:</div>
                                        <template x-for="p in friendRoom.participants" :key="p.user_id">
                                            <div
                                                class="flex items-center space-x-1 bg-white/5 px-2 py-1 rounded-full whitespace-nowrap border border-white/5 ring-1 ring-white/10">
                                                <div
                                                    class="w-1.5 h-1.5 rounded-full bg-green-500 animate-pulse shadow-[0_0_5px_rgba(34,197,94,0.5)]">
                                                </div>
                                                <span class="text-[10px] text-gray-300 font-medium"
                                                    x-text="p.username"></span>
                                            </div>
                                        </template>
                                    </div>

                                    <div class="flex-1 overflow-y-auto space-y-2 mb-4 pr-2" id="room-chat-messages">
                                        <template x-for="msg in friendRoom.messages" :key="msg.timestamp + msg.user_id">
                                            <div class="chat-msg flex flex-col"
                                                :class="msg.user_id === userId ? 'chat-msg-own' : ''">
                                                <span class="chat-username" x-text="msg.username"></span>
                                                <span class="text-white/90" x-text="msg.message"></span>
                                                <span class="text-[9px] text-gray-500 mt-1 self-end"
                                                    x-text="new Date(msg.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})"></span>
                                            </div>
                                        </template>
                                        <div x-show="friendRoom.messages.length === 0"
                                            class="text-center text-gray-500 text-sm py-10 italic">
                                            No messages yet. Say hi! ðŸ‘‹
                                        </div>
                                    </div>
                                    <div class="flex space-x-2 mt-auto">
                                        <input type="text" x-model="friendRoom.chatInput"
                                            @keydown.enter="sendRoomMessage()" placeholder="Type a message..."
                                            class="flex-1 glass px-4 py-2 rounded-lg text-sm focus:outline-none focus:ring-1 focus:ring-indigo-500">
                                        <button @click="sendRoomMessage()"
                                            class="bg-indigo-600 p-2 rounded-lg text-white">
                                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                    d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8" />
                                            </svg>
                                        </button>
                                    </div>
                                </div>
                            </template>
                            <template x-if="!friendRoom.currentRoomId">
                                <div class="flex flex-col items-center justify-center py-20 text-center px-4">
                                    <div
                                        class="w-16 h-16 bg-white/5 rounded-full flex items-center justify-center mb-4">
                                        <svg class="w-8 h-8 text-gray-500" fill="none" stroke="currentColor"
                                            viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                                d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z" />
                                        </svg>
                                    </div>
                                    <h3 class="text-lg font-bold mb-2">Room Chat</h3>
                                    <p class="text-sm text-gray-400 max-w-xs">
                                        Join or create a music room to chat with others in real-time.
                                    </p>
                                    <button @click="friendRoom.activeTab = 'rooms'"
                                        class="mt-6 bg-indigo-600 hover:bg-indigo-700 px-6 py-2 rounded-lg text-sm font-medium transition-colors">
                                        Go to Rooms
                                    </button>
                                </div>
                            </template>
                        </div>

                        <!-- Requests Tab -->
                        <div x-show="friendRoom.activeTab === 'requests'">
                            <div class="space-y-3">
                                <template x-for="req in friendRoom.requests" :key="req.user_id">
                                    <div class="flex items-center justify-between glass p-3 rounded-lg">
                                        <div class="flex items-center space-x-3">
                                            <div class="w-8 h-8 rounded-full bg-gray-600 flex items-center justify-center text-sm font-bold"
                                                x-text="req.username.charAt(0).toUpperCase()"></div>
                                            <div class="text-sm font-medium" x-text="req.username"></div>
                                        </div>
                                        <div class="flex space-x-2">
                                            <button @click="acceptRequest(req.user_id)"
                                                class="text-green-400 hover:text-green-300 p-1 bg-green-400/10 rounded">
                                                <svg class="w-5 h-5" fill="none" stroke="currentColor"
                                                    viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        stroke-width="2" d="M5 13l4 4L19 7" />
                                                </svg>
                                            </button>
                                            <button @click="rejectRequest(req.user_id)"
                                                class="text-red-400 hover:text-red-300 p-1 bg-red-400/10 rounded">
                                                <svg class="w-5 h-5" fill="none" stroke="currentColor"
                                                    viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round"
                                                        stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                                                </svg>
                                            </button>
                                        </div>
                                    </div>
                                </template>
                                <div x-show="friendRoom.requests.length === 0"
                                    class="text-center text-gray-500 text-sm py-4">No pending requests.</div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Search Songs Modal -->
            <div x-show="searchModal"
                class="fixed inset-0 z-50 flex items-end md:items-center justify-center p-0 md:p-4 bg-black/60 backdrop-blur-sm"
                x-transition:enter="transition ease-out duration-300"
                x-transition:enter-start="opacity-0 translate-y-full md:translate-y-0"
                x-transition:enter-end="opacity-100 translate-y-0" x-transition:leave="transition ease-in duration-200"
                x-transition:leave-start="opacity-100 translate-y-0"
                x-transition:leave-end="opacity-0 translate-y-full md:translate-y-0" style="display: none;">

                <div class="glass w-full max-w-2xl rounded-t-3xl md:rounded-2xl overflow-hidden shadow-2xl bg-black/40 h-[85vh] md:h-auto max-h-[85vh] md:max-h-[80vh] flex flex-col"
                    @click.away="searchModal = false">
                    <!-- Mobile Drag Handle -->
                    <div class="w-12 h-1.5 bg-white/20 rounded-full mx-auto my-3 md:hidden"></div>
                    <!-- Header -->
                    <div class="p-4 border-b border-white/10 flex justify-between items-center flex-shrink-0">
                        <h2 class="text-lg font-bold">Search Songs</h2>
                        <button @click="searchModal = false" class="text-gray-400 hover:text-white">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M6 18L18 6M6 6l12 12" />
                            </svg>
                        </button>
                    </div>

                    <!-- Search Input -->
                    <div class="p-4 border-b border-white/10 flex-shrink-0">
                        <div class="relative">
                            <input x-model="songSearchQuery" @input="searchSongsInModal()"
                                @keydown.enter.prevent="searchSongsInModal()" type="text"
                                placeholder="Search for songs, artists, albums..."
                                class="w-full glass px-4 py-3 pl-12 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500/50 transition-all placeholder:text-gray-600">
                            <svg class="absolute left-4 top-1/2 -translate-y-1/2 w-5 h-5 text-gray-400" fill="none"
                                stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                            </svg>
                            <div x-show="searchingSongs" class="absolute right-4 top-1/2 -translate-y-1/2">
                                <div
                                    class="w-5 h-5 border-2 border-cyan-500/30 border-t-cyan-500 rounded-full animate-spin">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Search Results -->
                    <div class="p-4 overflow-y-auto flex-1">
                        <!-- Results -->
                        <div x-show="songSearchResults.length > 0" class="space-y-2">
                            <template x-for="(song, index) in songSearchResults"
                                :key="song.platform_id || (song.title + '-' + index)">
                                <div @click="playSongFromSearch(song); searchModal = false"
                                    class="flex items-center space-x-3 p-3 rounded-lg bg-white/5 hover:bg-white/10 cursor-pointer transition-all group">
                                    <div
                                        class="w-16 h-16 rounded-lg overflow-hidden bg-gradient-to-br from-cyan-500 to-indigo-500 flex-shrink-0">
                                        <img :src="song.image" :alt="song.title" class="w-full h-full object-cover"
                                            @error="$el.style.display='none'">
                                    </div>
                                    <div class="flex-1 min-w-0">
                                        <p class="font-bold text-sm truncate" x-text="song.title"></p>
                                        <p class="text-xs text-gray-400 truncate"
                                            x-text="song.artists?.join(', ') || 'Unknown Artist'"></p>
                                        <p class="text-xs text-gray-500 truncate" x-show="song.album"
                                            x-text="song.album">
                                        </p>
                                    </div>
                                    <svg class="w-8 h-8 text-cyan-400 opacity-0 group-hover:opacity-100 transition-opacity flex-shrink-0"
                                        fill="currentColor" viewBox="0 0 24 24">
                                        <path d="M8 5v14l11-7z" />
                                    </svg>
                                </div>
                            </template>
                        </div>

                        <!-- Empty State -->
                        <div x-show="!songSearchQuery && songSearchResults.length === 0"
                            class="text-center py-12 text-gray-500">
                            <svg class="w-16 h-16 mx-auto mb-4 text-gray-600" fill="none" stroke="currentColor"
                                viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                            </svg>
                            <p class="text-sm">Search for songs to play</p>
                        </div>

                        <!-- No Results -->
                        <div x-show="songSearchQuery && songSearchResults.length === 0 && !searchingSongs"
                            class="text-center py-12 text-gray-500">
                            <p>No songs found</p>
                            <p class="text-xs mt-2">Try a different search term</p>
                        </div>

                        <!-- Loading -->
                        <div x-show="searchingSongs" class="text-center py-12">
                            <div
                                class="w-12 h-12 mx-auto border-4 border-cyan-500/30 border-t-cyan-500 rounded-full animate-spin">
                            </div>
                            <p class="text-sm text-gray-500 mt-4">Searching...</p>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Mobile Bottom Navigation -->
    <nav class="mobile-bottom-nav">
        <button @click="searchModal = false; friendRoom.isOpen = false" class="nav-item"
            :class="!searchModal && !friendRoom.isOpen ? 'active' : ''">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2z" />
            </svg>
            <span>Player</span>
        </button>
        <button @click="searchModal = true; friendRoom.isOpen = false" class="nav-item"
            :class="searchModal ? 'active' : ''">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
            </svg>
            <span>Search</span>
        </button>
        <button @click="friendRoom.isOpen = true; searchModal = false" class="nav-item"
            :class="friendRoom.isOpen ? 'active' : ''">
            <div class="relative">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                </svg>
                <span x-show="friendRoom.requests.length > 0"
                    class="absolute -top-1 -right-1 bg-red-500 text-white text-[8px] w-3 h-3 flex items-center justify-center rounded-full"
                    x-text="friendRoom.requests.length"></span>
            </div>
            <span>Social</span>
        </button>
    </nav>

    <script>
        // Auto-detect API URL
        const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8000/api/v1'
            : window.location.origin + '/api/v1';

        let ytPlayer = null;
        let ytApiReady = false;

        // YouTube IFrame API callback
        function onYouTubeIframeAPIReady() {
            ytApiReady = true;
            if (window.playAppInstance) {
                window.playAppInstance.initPlayer();
            }
        }

        function playApp() {
            return {
                playing: false,
                currentSong: null,
                recommendations: [],
                currentTime: 0,
                duration: 0,
                progressPercent: 0,
                loading: true,
                loading: true,
                userId: localStorage.getItem('aura_user_id') || 'guest_' + Math.random().toString(36).substr(2, 9),
                username: localStorage.getItem('aura_username') || 'Guest',
                authToken: localStorage.getItem('aura_user_token'),
                socket: null,
                room: null,
                isHost: false,
                adMonitoringInterval: null,

                // Pre-fetching cache for flawless playback
                prefetchCache: {},  // videoId cache: { 'title|artist': videoId }
                prefetchQueue: [],  // Songs being pre-fetched
                retryCount: {},     // Track retries per song
                // Pre-fetching cache for flawless playback
                prefetchCache: {},  // videoId cache: { 'title|artist': videoId }
                prefetchQueue: [],  // Songs being pre-fetched
                retryCount: {},     // Track retries per song
                maxRetries: 3,      // Max retries before skip
                mobileMode: false,  // Mobile optimization flag
                keepAliveInterval: null, // Heartbeat interval

                // Friend & Room State
                friendRoom: {
                    isOpen: false,
                    activeTab: 'friends', // 'friends', 'requests', 'rooms', 'chat'
                    friends: [],
                    requests: [],
                    rooms: [],
                    searchQuery: '',
                    searchResults: [],
                    newRoomName: '',
                    joinCode: '',
                    currentRoomId: null,
                    isHost: false,
                    participants: [],
                    queue: [],
                    messages: [],
                    chatInput: ''
                },

                // Search Modal State
                searchModal: false,
                songSearchQuery: '',
                songSearchResults: [],
                searchingSongs: false,
                songSearchTimeout: null,

                // Toast notification helper
                handleLogout() {
                    SharedApp.logout();
                },

                showToast(type, title, message, duration = 3000) {
                    SharedApp.showToast(type, title, message, duration);
                },

                // Initialize Socket.IO for real-time room sync
                initSocket() {
                    try {
                        // Socket.IO is optional - FriendRoomClient handles most functionality
                        if (typeof io !== 'undefined') {
                            const socketUrl = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                                ? 'http://localhost:8000'
                                : window.location.origin;

                            this.socket = io(socketUrl, {
                                transports: ['websocket', 'polling'],
                                reconnection: true,
                                reconnectionAttempts: 5,
                                reconnectionDelay: 1000
                            });

                            this.socket.on('connect', () => {
                                console.log('ðŸ”Œ Socket.IO connected');
                            });

                            this.socket.on('disconnect', () => {
                                console.log('ðŸ”Œ Socket.IO disconnected');
                            });

                            this.socket.on('connect_error', (error) => {
                                console.log('ðŸ”Œ Socket.IO connection error (non-critical):', error.message);
                                // Socket is optional, don't block functionality
                            });
                        } else {
                            console.log('ðŸ“¡ Socket.IO not loaded, using REST API fallback');
                        }
                    } catch (error) {
                        console.log('ðŸ“¡ Socket.IO initialization skipped:', error.message);
                        // Socket is optional, continue without it
                    }
                },

                // Get cache key for a song
                getCacheKey(song) {
                    const title = (song?.song?.title || song?.title || '').toLowerCase().trim();
                    const artist = (song?.song?.artists?.[0] || song?.artists?.[0] || '').toLowerCase().trim();
                    return `${title}|${artist}`;
                },

                async init() {
                    // Shared Init
                    this.mobileMode = SharedApp.checkMobileMode();
                    if (this.mobileMode) {
                        document.body.classList.add('mobile-mode');
                    }

                    // Check Auth via SharedApp
                    const isValid = await SharedApp.verifyToken();
                    if (!isValid && localStorage.getItem('aura_user_token')) {
                        this.handleLogout();
                        return;
                    }

                    this.authToken = localStorage.getItem('aura_user_token');
                    this.userId = localStorage.getItem('aura_user_id') || 'guest_' + Math.random().toString(36).substr(2, 9);
                    this.username = localStorage.getItem('aura_username') || 'Guest';
                    this.userEmail = localStorage.getItem('aura_user_email') || '';

                    // 2. Initialize Socket.IO
                    this.initSocket();
                    this.initFriendRoom(); // Initialize FriendRoom Client

                    // 3. Initialize Visualizer
                    this.resizeVisualizer();
                    window.addEventListener('resize', () => this.resizeVisualizer());
                    window.playAppInstance = this;

                    // 4. Initialize YouTube player and load songs
                    await this.waitForYouTubeAndLoad();

                    // 5. Start Keep-Alive System
                    this.startKeepAlive();

                    // 6. Register Service Worker
                    if ('serviceWorker' in navigator) {
                        navigator.serviceWorker.register('/static/sw.js')
                            .then(() => console.log('ðŸš€ Service Worker Registered'))
                            .catch(err => console.error('âŒ SW Registration failed:', err));
                    }

                    // 7. Initialize Media Session API
                    this.initMediaSession();
                },

                // Wait for YouTube API and then load songs
                async waitForYouTubeAndLoad() {
                    // Wait for YouTube API to be ready
                    const maxWaitTime = 10000; // 10 seconds max
                    const startTime = Date.now();

                    while (!ytApiReady && (Date.now() - startTime) < maxWaitTime) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }

                    if (ytApiReady) {
                        // Initialize the player
                        this.initPlayer();

                        // Wait a bit for player to be created
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } else {
                        console.warn('YouTube API not ready after timeout, loading songs anyway');
                    }

                    // Now load songs
                    const urlParams = new URLSearchParams(window.location.search);
                    const songParam = urlParams.get('song');
                    const roomParam = urlParams.get('room');

                    if (roomParam) {
                        console.log('Joining room from URL parameter:', roomParam);
                        await this.joinRoomById(roomParam.toUpperCase());
                    }

                    if (songParam) {
                        console.log('Loading song from URL parameter');
                        await this.loadSongFromId(songParam);
                    } else if (!roomParam) {
                        console.log('Loading recommendations...');
                        await this.loadRecommendations();
                    }
                },

                // Initialize Friend & Room Client
                async initFriendRoom() {
                    if (!window.FriendRoomClient) {
                        console.error('FriendRoomClient not loaded');
                        return;
                    }

                    window.friendRoomClient = new FriendRoomClient(API_BASE, this.authToken);

                    // Setup Callbacks
                    window.friendRoomClient.onRoomStateChange = (state) => {
                        console.log('Room State Changed:', state);

                        // Sync current song if different
                        if (state.current_song) {
                            // Handle both nested (.song.title) and flat (.title) song structures
                            const incomingTitle = state.current_song.song?.title || state.current_song.title;
                            const currentTitle = this.currentSong?.song?.title || this.currentSong?.title;

                            if (incomingTitle && incomingTitle.trim().toLowerCase() !== (currentTitle || '').trim().toLowerCase()) {
                                console.log('Syncing song from room:', incomingTitle);
                                this.currentSong = state.current_song;
                                this.loadSong(this.currentSong);
                            }
                        }

                        // Sync playback state
                        if (state.playback_state) {
                            const pb = state.playback_state;
                            console.log('Syncing playback state:', pb);

                            if (pb.is_playing !== this.playing) {
                                if (pb.is_playing) {
                                    if (ytPlayer && typeof ytPlayer.playVideo === 'function') ytPlayer.playVideo();
                                } else {
                                    if (ytPlayer && typeof ytPlayer.pauseVideo === 'function') ytPlayer.pauseVideo();
                                }
                            }

                            // Seek if drift is > 2 seconds
                            if (ytPlayer && typeof ytPlayer.getCurrentTime === 'function') {
                                const current = ytPlayer.getCurrentTime();
                                if (Math.abs(current - pb.current_time) > 2 && typeof ytPlayer.seekTo === 'function') {
                                    ytPlayer.seekTo(pb.current_time, true);
                                }
                            }
                        }
                    };

                    window.friendRoomClient.onUserJoined = (user) => {
                        this.showToast('info', 'Room Update', `${user.username || 'User'} joined the room`, 3000);
                        // Refresh room data
                        this.refreshRoomData();
                    };

                    window.friendRoomClient.onUserLeft = (user) => {
                        this.showToast('info', 'Room Update', `${user.username || 'User'} left the room`, 3000);
                        this.refreshRoomData();
                    };

                    window.friendRoomClient.onRoomChat = (data) => {
                        this.friendRoom.messages.push(data);
                        // Auto-scroll chat to bottom
                        this.$nextTick(() => {
                            const chatContainer = document.getElementById('room-chat-messages');
                            if (chatContainer) {
                                chatContainer.scrollTop = chatContainer.scrollHeight;
                            }
                        });

                        // Show toast if chat tab isn't active
                        if (!this.friendRoom.isOpen || this.friendRoom.activeTab !== 'chat') {
                            this.showToast('info', 'New Message', `${data.username}: ${data.message.substring(0, 20)}${data.message.length > 20 ? '...' : ''}`, 3000);
                        }
                    };

                    window.friendRoomClient.onParticipantsUpdate = (data) => {
                        console.log('Participants updated:', data);
                        if (data.participants) {
                            this.friendRoom.participants = data.participants;
                        }
                    };

                    // New: Join room by ID
                    this.joinRoomById = async (roomId) => {
                        try {
                            const response = await fetch(`${API_BASE}/rooms/join`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${this.authToken}`,
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({ room_id: roomId })
                            });

                            if (response.ok) {
                                const data = await response.json();
                                this.showToast('success', 'Joined Room', `Joined room ${roomId}`);
                                await window.friendRoomClient.joinRoom(roomId);
                                this.refreshRoomData();
                            } else {
                                this.showToast('warning', 'Join Failed', `Could not join room ${roomId}`);
                            }
                        } catch (e) {
                            console.error('Join room error:', e);
                        }
                    };

                    // Connect
                    if (this.authToken) {
                        await window.friendRoomClient.connect();
                        this.refreshFriendData();
                        this.refreshRoomData();

                        // Start synchronization if in a room
                        if (window.friendRoomClient.currentRoom) {
                            this.startRoomSync();
                        }
                    }
                },

                startRoomSync() {
                    if (!window.friendRoomClient || !window.friendRoomClient.isHost) return;

                    console.log('Starting Room Sync as Host');
                    window.friendRoomClient.startSync(() => {
                        if (!this.currentSong) return null;

                        return {
                            playback_state: {
                                is_playing: this.playing,
                                current_time: ytPlayer ? ytPlayer.getCurrentTime() : 0,
                                timestamp: Date.now()
                            },
                            current_song: this.currentSong
                        };
                    }, 2000); // Sync every 2 seconds
                },

                async refreshFriendData() {
                    if (!window.friendRoomClient) return;
                    try {
                        const friends = await window.friendRoomClient.getFriends();
                        this.friendRoom.friends = friends.friends || []; // Adjust based on actual API response
                        const requests = await window.friendRoomClient.getFriendRequests();
                        this.friendRoom.requests = requests.requests || [];
                    } catch (e) { console.error('Error fetching friends:', e); }
                },

                async refreshRoomData() {
                    if (!window.friendRoomClient) return;
                    // Logic to fetch room participants would go here if API supports it directly
                    // For now we might rely on socket updates or a separate call
                    if (window.friendRoomClient.currentRoom) {
                        this.friendRoom.currentRoomId = window.friendRoomClient.currentRoom;
                        // In a real implementation, we'd fetch room details including participants
                    } else {
                        this.friendRoom.currentRoomId = null;
                    }
                },

                // --- Friend Actions ---
                async sendFriendRequest() {
                    const username = this.friendRoom.searchQuery.trim();
                    if (!username) return;

                    try {
                        const res = await window.friendRoomClient.sendFriendRequest(username);
                        if (res.status === 'success') {
                            this.showToast('success', 'Request Sent', `Friend request sent to ${username}`);
                            this.friendRoom.searchQuery = '';
                        } else {
                            this.showToast('warning', 'Failed', res.detail || 'Could not send request');
                        }
                    } catch (e) {
                        this.showToast('error', 'Error', 'Failed to send request');
                        console.error(e);
                    }
                },

                async removeFriend(friendId) {
                    if (!confirm('Are you sure you want to remove this friend?')) return;
                    try {
                        await window.friendRoomClient.removeFriend(friendId);
                        this.showToast('success', 'Removed', 'Friend removed');
                        this.refreshFriendData();
                    } catch (e) { console.error(e); }
                },

                async acceptRequest(senderId) {
                    try {
                        await window.friendRoomClient.acceptFriendRequest(senderId);
                        this.showToast('success', 'Accepted', 'Friend request accepted');
                        this.refreshFriendData();
                    } catch (e) { console.error(e); }
                },

                async rejectRequest(senderId) {
                    try {
                        await window.friendRoomClient.rejectFriendRequest(senderId);
                        this.showToast('info', 'Rejected', 'Friend request rejected');
                        this.refreshFriendData();
                    } catch (e) { console.error(e); }
                },

                // --- Room Actions ---
                async createRoom() {
                    const name = this.friendRoom.newRoomName.trim() || `${this.username}'s Room`;
                    try {
                        const res = await window.friendRoomClient.createRoom(name);
                        if (res.status === 'success') {
                            this.friendRoom.currentRoomId = res.room_id;
                            this.friendRoom.isHost = true;
                            this.friendRoom.participants = [{ user_id: this.userId, username: this.username, is_host: true }];

                            // Populate queue with host's recommendations
                            this.friendRoom.queue = this.recommendations.map(rec => ({
                                title: rec.song?.title || rec.title,
                                artists: rec.song?.artists || rec.artists,
                                image: rec.song?.image || rec.image,
                                platform_id: rec.song?.platform_id || rec.platform_id,
                                recommendation_id: rec.recommendation_id,
                                song: rec.song || rec
                            }));

                            this.showToast('success', 'Room Created', `You are now host of "${name}" with ${this.friendRoom.queue.length} songs`);
                            this.friendRoom.newRoomName = '';
                            this.refreshRoomData();

                            // Join the socket room and start syncing
                            await window.friendRoomClient.joinRoom(res.room_id);
                            this.startRoomSync();
                        }
                    } catch (e) {
                        this.showToast('error', 'Error', 'Failed to create room');
                        console.error(e);
                    }
                },

                async leaveRoom() {
                    if (!this.friendRoom.currentRoomId) return;
                    try {
                        await window.friendRoomClient.leaveRoom();
                        this.friendRoom.currentRoomId = null;
                        this.friendRoom.isHost = false;
                        this.friendRoom.participants = [];
                        this.friendRoom.queue = [];
                        this.showToast('info', 'Left Room', 'You have left the room');
                        this.refreshRoomData();
                    } catch (e) { console.error(e); }
                },

                async joinRoomByCode() {
                    const code = this.friendRoom.joinCode.trim().toUpperCase();
                    if (!code || code.length !== 6) {
                        this.showToast('error', 'Invalid Code', 'Please enter a valid 6-character room code');
                        return;
                    }
                    try {
                        const res = await window.friendRoomClient.joinRoomAPI(code);
                        if (res.status === 'success' || res.room_id) {
                            this.friendRoom.currentRoomId = code;
                            this.friendRoom.isHost = res.is_host || false;
                            this.showToast('success', 'Joined Room', `You are now in room ${code}`);
                            this.friendRoom.joinCode = '';
                            await window.friendRoomClient.joinRoom(code);
                            this.refreshRoomData();
                        } else {
                            this.showToast('error', 'Join Failed', res.message || 'Could not join room');
                        }
                    } catch (e) {
                        this.showToast('error', 'Error', 'Failed to join room');
                        console.error(e);
                    }
                },

                sendRoomMessage() {
                    const msg = this.friendRoom.chatInput.trim();
                    if (!msg || !window.friendRoomClient) return;

                    window.friendRoomClient.sendChatMessage(msg);
                    this.friendRoom.chatInput = '';
                },

                clearQueue() {
                    this.friendRoom.queue = [];
                    // Emit to room if host
                    if (window.friendRoomClient && window.friendRoomClient.isHost) {
                        window.friendRoomClient.syncState({
                            is_playing: this.playing,
                            current_time: ytPlayer ? ytPlayer.getCurrentTime() : 0,
                            timestamp: Date.now()
                        }, this.currentSong);
                    }
                    this.showToast('info', 'Queue Cleared', 'The queue has been cleared');
                },

                removeFromQueue(index) {
                    if (index >= 0 && index < this.friendRoom.queue.length) {
                        const removed = this.friendRoom.queue.splice(index, 1);
                        this.showToast('info', 'Removed', `Removed "${removed[0]?.title || 'song'}" from queue`);
                    }
                },

                // Keep-Alive System (Client-side)
                startKeepAlive() {
                    // Ping server every 4.5 minutes (270s) to keep Render instance awake
                    // Render sleeps after 15 mins of inactivity.
                    console.log('ðŸ’“ efficient-keep-alive: Started (4.5m interval)');

                    this.keepAliveInterval = setInterval(async () => {
                        try {
                            const response = await fetch(`${API_BASE}/health`);
                            if (response.ok) {
                                console.debug('ðŸ’“ keep-alive: ping success');
                            }
                        } catch (e) {
                            console.debug('âš  keep-alive: ping failed', e);
                        }
                    }, 270000); // 4.5 minutes
                },

                initPlayer() {
                    if (ytPlayer) return;

                    // Create player with nocookie domain (fewer ads)
                    // We'll override the embed URL to use nocookie domain
                    ytPlayer = new YT.Player('youtube-player', {
                        height: '1',
                        width: '1',
                        playerVars: {
                            'autoplay': 0,
                            'controls': 0,
                            'disablekb': 1,
                            'enablejsapi': 1,
                            'fs': 0,
                            'iv_load_policy': 3,
                            'modestbranding': 1,
                            'playsinline': 1,
                            'rel': 0,
                            'cc_load_policy': 0,  // Don't load captions
                            'loop': 0,
                            'mute': 0,
                            'start': 0,
                            // Ad blocking parameters
                            'origin': window.location.origin,
                            'widget_referrer': window.location.origin
                        },
                        events: {
                            'onReady': (event) => {
                                console.log('YouTube player ready');
                            },
                            'onStateChange': (event) => {
                                if (event.data === YT.PlayerState.PLAYING) {
                                    this.playing = true;
                                    this.syncCatState();

                                    // Sync play state to room
                                    if (window.friendRoomClient && window.friendRoomClient.isHost) {
                                        window.friendRoomClient.syncState({
                                            is_playing: true,
                                            current_time: ytPlayer.getCurrentTime(),
                                            timestamp: Date.now()
                                        }, this.currentSong);
                                    }

                                    // Start aggressive ad monitoring
                                    this.startAdMonitoring();

                                    // Immediate ad detection
                                    setTimeout(() => this.detectAndSkipAds(), 500);
                                    setTimeout(() => this.detectAndSkipAds(), 1500);
                                    setTimeout(() => this.detectAndSkipAds(), 3000);
                                } else if (event.data === YT.PlayerState.PAUSED) {
                                    this.playing = false;
                                    this.syncCatState();

                                    // Sync pause state to room
                                    if (window.friendRoomClient && window.friendRoomClient.isHost) {
                                        window.friendRoomClient.syncState({
                                            is_playing: false,
                                            current_time: ytPlayer.getCurrentTime(),
                                            timestamp: Date.now()
                                        }, this.currentSong);
                                    }

                                    this.stopAdMonitoring();
                                } else if (event.data === YT.PlayerState.ENDED) {
                                    this.playing = false;
                                    this.syncCatState();
                                    this.stopAdMonitoring();
                                    this.nextSong();
                                } else if (event.data === YT.PlayerState.CUED) {
                                    // Video is cued (often happens before ads)
                                    this.detectAndSkipAds();
                                } else if (event.data === YT.PlayerState.ERROR) {
                                    console.error('YouTube player error - video may be unavailable');
                                    this.stopAdMonitoring();
                                    // Try to skip to next song if current one fails
                                    if (this.currentSong) {
                                        alert(`Unable to play "${this.currentSong.song?.title || 'this song'}". Skipping to next song.`);
                                        this.nextSong();
                                    }
                                }
                            },
                            'onError': (event) => {
                                console.error('YouTube player error code:', event.data);
                                // Error codes: 2=invalid video, 5=HTML5 error, 100=video not found, 101/150=not allowed to embed
                                const errorMessages = {
                                    2: 'Invalid video parameter',
                                    5: 'HTML5 player error',
                                    100: 'Video not found',
                                    101: 'Video not allowed to be played in embedded players',
                                    150: 'Video not allowed to be played in embedded players'
                                };
                                const errorMsg = errorMessages[event.data] || 'Unknown error';
                                console.error('YouTube error:', errorMsg);

                                // For invalid video parameter (error 2), try to refetch video ID
                                if (event.data === 2 && this.currentSong && !this.currentSong._retryAttempted) {
                                    console.log('Invalid video ID detected, attempting to refetch...');
                                    this.currentSong._retryAttempted = true;
                                    this.currentSong.youtube_video_id = null;
                                    if (this.currentSong.song) {
                                        this.currentSong.song.youtube_video_id = null;
                                    }

                                    // Refetch video ID with a slight delay
                                    setTimeout(async () => {
                                        await this.fetchYouTubeVideoId(this.currentSong);
                                        const newVideoId = this.currentSong.youtube_video_id || this.currentSong.song?.youtube_video_id;
                                        if (newVideoId) {
                                            console.log('Retrying with new video ID:', newVideoId);
                                            this.loadSong(this.currentSong);
                                        } else {
                                            // If still no valid video ID, skip to next
                                            this.showToast('warning', 'Video Not Found', `Skipping "${this.currentSong.song?.title || 'this song'}"`, 3000);
                                            this.nextSong();
                                        }
                                    }, 1000);
                                } else {
                                    // For other errors or if retry already attempted, skip to next song
                                    if (this.currentSong) {
                                        this.showToast('warning', 'Playback Error', `Skipping "${this.currentSong.song?.title || 'this song'}": ${errorMsg}`, 3000);
                                        this.nextSong();
                                    }
                                }
                            }
                        }
                    });
                },

                initMediaSession() {
                    if ('mediaSession' in navigator) {
                        navigator.mediaSession.setActionHandler('play', () => {
                            if (ytPlayer && typeof ytPlayer.playVideo === 'function') ytPlayer.playVideo();
                        });
                        navigator.mediaSession.setActionHandler('pause', () => {
                            if (ytPlayer && typeof ytPlayer.pauseVideo === 'function') ytPlayer.pauseVideo();
                        });
                        navigator.mediaSession.setActionHandler('previoustrack', () => {
                            this.previousSong();
                        });
                        navigator.mediaSession.setActionHandler('nexttrack', () => {
                            this.nextSong();
                        });
                        navigator.mediaSession.setActionHandler('seekto', (details) => {
                            if (ytPlayer && details.seekTime && typeof ytPlayer.seekTo === 'function') {
                                ytPlayer.seekTo(details.seekTime, true);
                            }
                        });
                    }
                },

                updateMediaSession() {
                    if ('mediaSession' in navigator && this.currentSong) {
                        const song = this.currentSong.song || this.currentSong;
                        navigator.mediaSession.metadata = new MediaMetadata({
                            title: song.title || 'Unknown Title',
                            artist: (song.artists && Array.isArray(song.artists) ? song.artists.join(', ') : song.artists) || 'Unknown Artist',
                            album: 'Aura Social Player',
                            artwork: [
                                { src: song.image || 'https://img.icons8.com/clouds/500/cat.png', sizes: '512x512', type: 'image/png' }
                            ]
                        });

                        // Start silent audio to keep session active on mobile background
                        const silentAudio = document.getElementById('bg-persistence-audio');
                        if (silentAudio && silentAudio.paused) {
                            silentAudio.play().catch(e => console.log('Silent audio play blocked by browser policy'));
                        }
                    }
                },

                async loadRecommendations(preserveCurrentSong = false, genre = null) {
                    this.loading = true;
                    try {
                        // Build URL with optional genre parameter
                        let url = `${API_BASE}/recommendations?user_id=${this.userId}&limit=10`;
                        if (genre) {
                            url += `&genre=${encodeURIComponent(genre)}`;
                        }

                        const response = await fetch(url);
                        const data = await response.json();
                        if (data.recommendations && data.recommendations.length > 0) {
                            this.recommendations = data.recommendations;
                            // Only set currentSong if we're not preserving it (i.e., when loading initial recommendations)
                            if (!preserveCurrentSong) {
                                this.currentSong = this.recommendations[0];
                                this.loadSong(this.currentSong);
                                this.syncCatState();
                            }
                        }
                    } catch (error) {
                        console.error('Error loading recommendations:', error);
                    } finally {
                        this.loading = false;
                    }
                },

                async loadSongFromId(songId) {
                    this.loading = true;
                    try {
                        // Check if songId is a JSON string (from search results)
                        let songData = null;
                        try {
                            songData = JSON.parse(decodeURIComponent(songId));
                            // If parsing succeeds, it's a song object from search
                            if (songData.title) {
                                // Create a recommendation-like object from the song data
                                const songObj = {
                                    recommendation_id: `search_${Date.now()}`,
                                    song: {
                                        title: songData.title,
                                        artists: songData.artists || [],
                                        image: songData.image || '',
                                        album: songData.album || '',
                                        genre: songData.genre || [],
                                        youtube_video_id: songData.youtube_video_id || null
                                    },
                                    youtube_video_id: songData.youtube_video_id || null
                                };

                                // Fetch YouTube video ID if not present
                                if (!songObj.youtube_video_id && !songObj.song.youtube_video_id) {
                                    await this.fetchYouTubeVideoId(songObj);
                                }

                                this.currentSong = songObj;
                                this.loadSong(songObj);
                                this.syncCatState();

                                // Extract genre from the searched song
                                const songGenres = songObj.song?.genre || songData.genre || [];
                                const genreParam = songGenres.length > 0 ? songGenres.join(',') : null;

                                // Load recommendations for queue (preserve current song) with genre filter
                                await this.loadRecommendations(true, genreParam);

                                // Insert the searched song at the beginning of recommendations queue
                                if (this.recommendations.length > 0) {
                                    this.recommendations.unshift(songObj);
                                } else {
                                    this.recommendations = [songObj];
                                }
                                return;
                            }
                        } catch (e) {
                            // Not a JSON string, treat as recommendation_id
                        }

                        // Try to find in recommendations
                        const response = await fetch(`${API_BASE}/recommendations?user_id=${this.userId}&limit=50`);
                        const data = await response.json();
                        if (data.recommendations) {
                            this.recommendations = data.recommendations;
                            const song = data.recommendations.find(r => r.recommendation_id === songId);
                            if (song) {
                                this.currentSong = song;
                                // Fetch YouTube video ID if not present
                                if (!song.youtube_video_id && !song.song?.youtube_video_id) {
                                    await this.fetchYouTubeVideoId(song);
                                }
                                this.loadSong(song);
                            } else if (data.recommendations.length > 0) {
                                this.currentSong = data.recommendations[0];
                                if (!this.currentSong.youtube_video_id && !this.currentSong.song?.youtube_video_id) {
                                    await this.fetchYouTubeVideoId(this.currentSong);
                                }
                                this.loadSong(this.currentSong);
                            }
                        }
                    } catch (error) {
                        console.error('Error loading song:', error);
                    } finally {
                        this.loading = false;
                    }
                },

                async fetchYouTubeVideoId(song, retryCount = 0) {
                    try {
                        const title = song.song?.title || song.title;
                        const artists = song.song?.artists || song.artists || [];
                        const artistsStr = Array.isArray(artists) ? artists.join(',') : artists;

                        if (!title) return;

                        const response = await fetch(
                            `${API_BASE}/songs/youtube-video-id?title=${encodeURIComponent(title)}&artists=${encodeURIComponent(artistsStr)}`
                        );
                        const data = await response.json();

                        if (data.youtube_video_id) {
                            // Validate video ID format
                            const videoId = data.youtube_video_id.trim();
                            if (videoId.length === 11 && /^[a-zA-Z0-9_-]+$/.test(videoId)) {
                                // Update song object with video ID
                                if (song.song) {
                                    song.song.youtube_video_id = videoId;
                                }
                                song.youtube_video_id = videoId;

                                // If this is the current song and player is ready, load it
                                if (this.currentSong === song && ytPlayer) {
                                    this.loadSong(song);
                                }
                            } else {
                                console.error('Invalid video ID format:', videoId);
                                // Retry if we haven't retried too many times
                                if (retryCount < 2) {
                                    setTimeout(() => this.fetchYouTubeVideoId(song, retryCount + 1), 1000);
                                }
                            }
                        } else if (retryCount < 2) {
                            // Retry if no video ID found
                            setTimeout(() => this.fetchYouTubeVideoId(song, retryCount + 1), 1000);
                        }
                    } catch (error) {
                        console.error('Error fetching YouTube video ID:', error);
                        // Retry on error
                        if (retryCount < 2) {
                            setTimeout(() => this.fetchYouTubeVideoId(song, retryCount + 1), 1000);
                        }
                    }
                },

                async loadSong(song) {
                    if (!song) return;

                    // Update Media Session Metadata
                    this.updateMediaSession();

                    const cacheKey = this.getCacheKey(song);

                    // Check prefetch cache first
                    let videoId = this.prefetchCache[cacheKey] || song.youtube_video_id || song.song?.youtube_video_id;

                    if (!videoId) {
                        // Show loading toast
                        this.showToast('info', 'Loading', `Finding "${song.song?.title || song.title}"...`, 2000);

                        // Try to fetch it
                        await this.fetchYouTubeVideoId(song);
                        videoId = song.youtube_video_id || song.song?.youtube_video_id;
                    }

                    if (!videoId) {
                        // Track retry count
                        const retryKey = cacheKey;
                        this.retryCount[retryKey] = (this.retryCount[retryKey] || 0) + 1;

                        if (this.retryCount[retryKey] < this.maxRetries) {
                            // Try alternative query
                            this.showToast('info', 'Retrying', `Searching for "${song.song?.title || song.title}" (attempt ${this.retryCount[retryKey] + 1})...`, 2000);

                            // Modify search to try alternative patterns
                            const title = song.song?.title || song.title;
                            const artists = song.song?.artists || song.artists || [];
                            const altQueries = [
                                `${title} ${artists[0] || ''} lyrics`,
                                `${title} ${artists[0] || ''} audio`,
                                `${title} official`
                            ];

                            for (const query of altQueries) {
                                try {
                                    const response = await fetch(
                                        `${API_BASE}/songs/youtube-video-id?title=${encodeURIComponent(query)}&artists=`
                                    );
                                    const data = await response.json();
                                    if (data.youtube_video_id && /^[a-zA-Z0-9_-]{11}$/.test(data.youtube_video_id)) {
                                        videoId = data.youtube_video_id;
                                        // Cache it
                                        this.prefetchCache[cacheKey] = videoId;
                                        if (song.song) song.song.youtube_video_id = videoId;
                                        song.youtube_video_id = videoId;
                                        break;
                                    }
                                } catch (e) {
                                    console.debug('Alt query failed:', query);
                                }
                            }
                        }

                        if (!videoId) {
                            console.error('No video ID found for song:', song.song?.title || song.title);
                            this.showToast('error', 'Song Unavailable', `Skipping "${song.song?.title || song.title}"`, 3000);
                            // Auto-skip to next song
                            setTimeout(() => this.nextSong(), 500);
                            return;
                        }
                    }

                    // Cache the videoId
                    this.prefetchCache[cacheKey] = videoId;

                    if (!ytPlayer) {
                        console.error('YouTube player not ready');
                        // Wait a bit and try again
                        setTimeout(() => this.loadSong(song), 500);
                        return;
                    }

                    // Validate video ID before loading
                    if (!/^[a-zA-Z0-9_-]{11}$/.test(videoId)) {
                        console.error('Invalid video ID format:', videoId);
                        this.showToast('error', 'Invalid Video', `Skipping "${song.song?.title || song.title}"`, 3000);
                        setTimeout(() => this.nextSong(), 500);
                        return;
                    }

                    try {
                        // Stop any existing ad monitoring
                        this.stopAdMonitoring();

                        // Force use of nocookie domain for fewer ads
                        const playerElement = document.getElementById('youtube-player');
                        if (playerElement) {
                            const iframe = playerElement.querySelector('iframe');
                            if (iframe && iframe.src) {
                                // Replace youtube.com with youtube-nocookie.com
                                iframe.src = iframe.src.replace('youtube.com', 'youtube-nocookie.com');
                            }
                        }

                        ytPlayer.loadVideoById(videoId);
                        this.playing = false;
                        this.currentTime = 0;
                        this.duration = 0;

                        // Trigger immediate sync for room
                        if (window.friendRoomClient && window.friendRoomClient.isHost) {
                            window.friendRoomClient.syncState({
                                is_playing: this.playing,
                                current_time: 0,
                                timestamp: Date.now()
                            }, song);
                        }

                        // Start monitoring for ads after video loads
                        setTimeout(() => {
                            if (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                                this.startAdMonitoring();
                            }
                        }, 1000);

                        // PRE-FETCH next 2 songs for seamless playback
                        this.prefetchNextSongs();

                    } catch (error) {
                        console.error('Error loading video:', error);
                        // Try to refetch video ID if loading fails
                        if (!song._retryAttempted) {
                            song._retryAttempted = true;
                            console.log('Retrying with new video ID...');
                            await this.fetchYouTubeVideoId(song);
                            const newVideoId = song.youtube_video_id || song.song?.youtube_video_id;
                            if (newVideoId && newVideoId !== videoId) {
                                setTimeout(() => this.loadSong(song), 500);
                            }
                        }
                    }
                },

                // Pre-fetch video IDs for upcoming songs
                async prefetchNextSongs() {
                    if (this.recommendations.length <= 1) return;

                    const currentIndex = this.recommendations.findIndex(r =>
                        r.recommendation_id === this.currentSong?.recommendation_id
                    );

                    // Pre-fetch next 2 songs
                    for (let i = 1; i <= 2; i++) {
                        const nextIndex = (currentIndex + i) % this.recommendations.length;
                        const nextSong = this.recommendations[nextIndex];

                        if (!nextSong) continue;

                        const cacheKey = this.getCacheKey(nextSong);

                        // Skip if already cached
                        if (this.prefetchCache[cacheKey]) continue;

                        // Skip if already has video ID
                        if (nextSong.youtube_video_id || nextSong.song?.youtube_video_id) {
                            this.prefetchCache[cacheKey] = nextSong.youtube_video_id || nextSong.song?.youtube_video_id;
                            continue;
                        }

                        // Fetch in background (don't await)
                        this.fetchYouTubeVideoId(nextSong).then(() => {
                            if (nextSong.youtube_video_id || nextSong.song?.youtube_video_id) {
                                this.prefetchCache[cacheKey] = nextSong.youtube_video_id || nextSong.song?.youtube_video_id;
                                console.log(`Pre-fetched: ${nextSong.song?.title || nextSong.title}`);
                            }
                        }).catch(e => console.debug('Prefetch failed:', e));
                    }
                },

                playSong(song) {
                    // Stop any existing ad monitoring
                    this.stopAdMonitoring();

                    this.currentSong = song;
                    this.loadSong(song);
                    this.syncCatState();
                    this.vibrate(10); // Haptic feedback

                    // Immediate sync to room
                    if (window.friendRoomClient && window.friendRoomClient.isHost) {
                        window.friendRoomClient.syncState({
                            is_playing: this.playing,
                            current_time: 0,
                            timestamp: Date.now()
                        }, this.currentSong);
                    }
                },

                togglePlay() {
                    if (!ytPlayer || !this.currentSong) return;

                    if (this.playing) {
                        if (typeof ytPlayer.pauseVideo === 'function') {
                            ytPlayer.pauseVideo();
                        }
                    } else {
                        if (typeof ytPlayer.playVideo === 'function') {
                            ytPlayer.playVideo();
                        }
                    }
                    this.vibrate(10); // Haptic feedback
                },

                nextSong() {
                    // Stop ad monitoring when skipping
                    this.stopAdMonitoring();

                    // If in a room with queue, play from queue
                    if (this.friendRoom.currentRoomId && this.friendRoom.queue.length > 0) {
                        // Take the first song from queue
                        const nextFromQueue = this.friendRoom.queue.shift();
                        if (nextFromQueue) {
                            // Play and sync to room if host
                            this.loadSong(nextFromQueue.song || nextFromQueue);

                            if (this.friendRoom.isHost && window.friendRoomClient) {
                                window.friendRoomClient.syncState({
                                    is_playing: true,
                                    current_time: 0,
                                    timestamp: Date.now(),
                                    queue: this.friendRoom.queue
                                }, nextFromQueue.song || nextFromQueue);
                            }
                            this.vibrate(15);
                            return;
                        }
                    }

                    // Fall back to recommendations
                    if (this.recommendations.length === 0) return;

                    const currentIndex = this.recommendations.findIndex(r =>
                        r.recommendation_id === this.currentSong?.recommendation_id
                    );
                    const nextIndex = (currentIndex + 1) % this.recommendations.length;
                    this.playSong(this.recommendations[nextIndex]);
                    this.vibrate(15); // Haptic feedback
                },

                previousSong() {
                    if (this.recommendations.length === 0) return;

                    const currentIndex = this.recommendations.findIndex(r =>
                        r.recommendation_id === this.currentSong?.recommendation_id
                    );
                    const prevIndex = currentIndex <= 0 ? this.recommendations.length - 1 : currentIndex - 1;
                    this.playSong(this.recommendations[prevIndex]);
                    this.vibrate(15); // Haptic feedback
                },

                detectAndSkipAds() {
                    // Enhanced ad detection and skipping
                    if (!ytPlayer) return;

                    try {
                        const duration = ytPlayer.getDuration();
                        const currentTime = ytPlayer.getCurrentTime();
                        const videoData = ytPlayer.getVideoData ? ytPlayer.getVideoData() : null;

                        // Method 1: Detect ads by duration (ads are typically 5-30 seconds)
                        // But be careful - some songs are short too
                        if (duration > 0 && duration <= 35 && currentTime < 10) {
                            // Check if this is likely an ad (very short, just started)
                            const isLikelyAd = duration <= 35 && currentTime < 5;

                            if (isLikelyAd) {
                                console.log(`Detected potential ad (${duration}s), attempting to skip...`);

                                // Try to seek to end of ad
                                try {
                                    ytPlayer.seekTo(duration - 0.5, true);
                                    console.log('Sought to end of ad');
                                } catch (e) {
                                    console.debug('Could not seek:', e);
                                }

                                // If still playing after 2 seconds, skip to next song
                                setTimeout(() => {
                                    if (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING) {
                                        const newTime = ytPlayer.getCurrentTime();
                                        const newDuration = ytPlayer.getDuration();

                                        // If still a short video, it's likely an ad
                                        if (newDuration <= 35 && newTime < newDuration - 1) {
                                            console.log('Ad detected, skipping to next song');
                                            this.nextSong();
                                        }
                                    }
                                }, 2000);
                            }
                        }

                        // Method 2: Detect ads by checking if video title/author suggests it's an ad
                        if (videoData) {
                            const title = (videoData.title || '').toLowerCase();
                            const author = (videoData.author || '').toLowerCase();

                            // Common ad indicators
                            const adKeywords = ['advertisement', 'ad', 'sponsored', 'promo', 'commercial'];
                            const isAdByTitle = adKeywords.some(keyword => title.includes(keyword));

                            if (isAdByTitle && duration <= 60) {
                                console.log('Ad detected by title, skipping...');
                                this.nextSong();
                                return;
                            }
                        }

                        // Method 3: Monitor for sudden state changes that might indicate ads
                        // This will be handled by the onStateChange handler

                    } catch (e) {
                        console.debug('Ad detection error:', e);
                    }
                },

                // Enhanced ad monitoring with interval
                startAdMonitoring() {
                    // Clear any existing interval
                    if (this.adMonitoringInterval) {
                        clearInterval(this.adMonitoringInterval);
                    }

                    // Monitor for ads every 500ms when playing
                    this.adMonitoringInterval = setInterval(() => {
                        if (this.playing && ytPlayer) {
                            this.detectAndSkipAds();
                        }
                    }, 500);
                },

                stopAdMonitoring() {
                    if (this.adMonitoringInterval) {
                        clearInterval(this.adMonitoringInterval);
                        this.adMonitoringInterval = null;
                    }
                },

                updateProgress() {
                    if (!ytPlayer || !this.currentSong) return;

                    try {
                        this.currentTime = ytPlayer.getCurrentTime() || 0;
                        this.duration = ytPlayer.getDuration() || 0;
                        this.progressPercent = this.duration > 0 ? (this.currentTime / this.duration) * 100 : 0;
                    } catch (e) {
                        // Player might not be ready
                    }
                },

                seekTo(event) {
                    if (!ytPlayer || !this.currentSong) return;

                    const rect = event.currentTarget.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const percent = x / rect.width;
                    const time = percent * this.duration;
                    ytPlayer.seekTo(time, true);
                },

                formatTime(seconds) {
                    if (!seconds || isNaN(seconds)) return '0:00';
                    const mins = Math.floor(seconds / 60);
                    const secs = Math.floor(seconds % 60);
                    return `${mins}:${secs.toString().padStart(2, '0')}`;
                },

                async submitFeedback(type) {
                    if (!this.currentSong) return;

                    try {
                        await fetch(`${API_BASE}/feedback`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                user_id: this.userId,
                                recommendation_id: this.currentSong.recommendation_id,
                                song_id: this.currentSong.song?.title || this.currentSong.recommendation_id,
                                feedback_type: type,
                                context: { time_of_day: this.getTimeOfDay() }
                            })
                        });

                        // Track listening if liked
                        if (type === 'like' && this.currentSong.song) {
                            await fetch(`${API_BASE}/listening/track`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    user_id: this.userId,
                                    song_title: this.currentSong.song.title,
                                    artists: this.currentSong.song.artists || [],
                                    source: 'recommendation',
                                    platform: 'youtube',
                                    metadata: {}
                                })
                            });
                        }

                        if (type === 'skip') {
                            this.nextSong();
                        }
                    } catch (error) {
                        console.error('Error submitting feedback:', error);
                    }
                },

                getTimeOfDay() {
                    const hour = new Date().getHours();
                    if (hour < 12) return 'morning';
                    if (hour < 17) return 'afternoon';
                    if (hour < 21) return 'evening';
                    return 'night';
                },

                syncCatState() {
                    // Sync state with Alpine store for cat to react
                    if (window.Alpine && window.Alpine.store) {
                        try {
                            window.Alpine.store('playApp', {
                                playing: this.playing,
                                currentSong: this.currentSong
                            });
                        } catch (e) {
                            // Store might not be initialized yet
                        }
                    }
                },

                // Search Songs in Modal
                async searchSongsInModal() {
                    if (this.songSearchTimeout) {
                        clearTimeout(this.songSearchTimeout);
                    }

                    if (!this.songSearchQuery || this.songSearchQuery.length < 2) {
                        this.songSearchResults = [];
                        return;
                    }

                    this.songSearchTimeout = setTimeout(async () => {
                        this.searchingSongs = true;
                        try {
                            const response = await fetch(`${API_BASE}/songs/search?q=${encodeURIComponent(this.songSearchQuery)}&limit=15`);
                            const data = await response.json();

                            if (response.ok) {
                                this.songSearchResults = data.results || data.songs || [];
                                if (this.songSearchResults.length === 0 && this.songSearchQuery.length >= 2) {
                                    console.log('No results found for query:', this.songSearchQuery);
                                }
                            } else {
                                this.songSearchResults = [];
                                if (data.error) {
                                    this.showToast('error', 'Search Error', data.error, 3000);
                                }
                            }
                        } catch (error) {
                            console.error('Search error:', error);
                            this.songSearchResults = [];
                        } finally {
                            this.searchingSongs = false;
                        }
                    }, 300);
                },

                async playSongFromSearch(song) {
                    console.log('Playing song from search:', song);

                    // If host and in a room, add to queue and sync
                    if (this.friendRoom.currentRoomId && this.friendRoom.isHost) {
                        // Add to queue
                        this.friendRoom.queue.push({
                            title: song.title,
                            artists: song.artists,
                            image: song.image,
                            platform_id: song.platform_id,
                            song: song
                        });
                        this.showToast('success', 'Added to Queue', `"${song.title}" added to room queue`);

                        // Sync queue to room
                        if (window.friendRoomClient) {
                            window.friendRoomClient.syncState({
                                is_playing: this.playing,
                                current_time: ytPlayer ? ytPlayer.getCurrentTime() : 0,
                                timestamp: Date.now(),
                                queue: this.friendRoom.queue
                            }, this.currentSong);
                        }
                    } else {
                        // Not in room or not host - play immediately
                        await this.loadSong(song);
                    }
                },

                // Add song to queue (host only)
                addToQueue(song) {
                    if (!this.friendRoom.isHost) return;
                    this.friendRoom.queue.push({
                        title: song.title || song.song?.title,
                        artists: song.artists || song.song?.artists,
                        image: song.image || song.song?.image,
                        platform_id: song.platform_id || song.song?.platform_id,
                        song: song.song || song
                    });
                    this.showToast('success', 'Added', `"${song.title || song.song?.title}" added to queue`);
                },

                // Mobile Haptics
                vibrate(ms) {
                    if (this.mobileMode && navigator.vibrate) {
                        navigator.vibrate(ms);
                    }
                },

                // Visualizer Initialization & Tuning
                resizeVisualizer() {
                    const canvas = document.querySelector('canvas'); // Or wherever visualizer is
                    // Note: We don't have a canvas visualizer in this HTML, it uses div bars.
                    // If we did, we would do:
                    /*
                    if (this.mobileMode) {
                         analyser.fftSize = 128; // Low quality for mobile
                    } else {
                         analyser.fftSize = 2048; // High quality
                    }
                    */
                    // For CSS bars, we just adjust logic if needed, but current CSS bars are lightweight.
                }
            }
        }

        // Cat Emotion System - Advanced Version
        function catEmotion() {
            return {
                emotion: 'idle',
                mood: 'content', // content, happy, excited, sleepy, vibing
                speechVisible: false,
                speechText: '',
                lastSongTitle: '',
                catX: 40,
                catY: 40,
                eyeOffsetX: 0,
                eyeOffsetY: 0,
                isGlowing: false,
                isPurring: false,
                isVibing: false,
                isDragging: false,
                dragStartX: 0,
                dragStartY: 0,
                playing: false,
                clickCount: 0,
                lastClickTime: 0,
                particleInterval: null,
                zzzInterval: null,

                init() {
                    // Update state from main app
                    setInterval(() => {
                        if (window.playAppInstance) {
                            const wasPlaying = this.playing;
                            this.playing = window.playAppInstance.playing;

                            // Detect state changes
                            if (!wasPlaying && this.playing) {
                                this.onMusicStart();
                            } else if (wasPlaying && !this.playing) {
                                this.onMusicStop();
                            }
                        }
                        this.updateEyes();
                        this.checkForNewSong();
                        this.updatePosition();
                        this.updateMood();
                    }, 50);

                    document.addEventListener('mousemove', (e) => {
                        this.mouseX = e.clientX;
                        this.mouseY = e.clientY;
                        if (this.isDragging) {
                            this.handleDrag(e);
                        }
                    });

                    document.addEventListener('touchmove', (e) => {
                        if (e.touches && e.touches[0]) {
                            this.mouseX = e.touches[0].clientX;
                            this.mouseY = e.touches[0].clientY;
                            if (this.isDragging) {
                                this.handleDrag(e.touches[0]);
                            }
                        }
                    }, { passive: false });

                    document.addEventListener('mouseup', () => this.stopDrag());
                    document.addEventListener('touchend', () => this.stopDrag());
                },

                onMusicStart() {
                    this.mood = 'vibing';
                    this.isVibing = true;
                    this.startNoteParticles();
                    this.stopZzzParticles();
                    const messages = [
                        'ðŸŽµ Yesss, music time!',
                        'ðŸŽ§ Let\'s vibe!',
                        'ðŸŽ¶ My jam!',
                        'ðŸ’ƒ Dance mode activated!',
                        'âœ¨ This slaps!'
                    ];
                    this.showSpeech(messages[Math.floor(Math.random() * messages.length)], 2000);
                },

                onMusicStop() {
                    this.mood = 'sleepy';
                    this.isVibing = false;
                    this.stopNoteParticles();
                    setTimeout(() => this.startZzzParticles(), 3000);
                    const messages = [
                        'ðŸ˜´ Sleepy time...',
                        'ðŸ’¤ *yawns*',
                        'ðŸ¥± More music pls...',
                        'ðŸ˜¿ Why did it stop?'
                    ];
                    this.showSpeech(messages[Math.floor(Math.random() * messages.length)], 2000);
                },

                startNoteParticles() {
                    if (this.particleInterval) clearInterval(this.particleInterval);
                    this.particleInterval = setInterval(() => {
                        if (this.playing) this.spawnNote();
                    }, 800);
                },

                stopNoteParticles() {
                    if (this.particleInterval) {
                        clearInterval(this.particleInterval);
                        this.particleInterval = null;
                    }
                },

                startZzzParticles() {
                    if (this.zzzInterval) clearInterval(this.zzzInterval);
                    this.zzzInterval = setInterval(() => {
                        if (!this.playing) this.spawnZzz();
                    }, 2000);
                },

                stopZzzParticles() {
                    if (this.zzzInterval) {
                        clearInterval(this.zzzInterval);
                        this.zzzInterval = null;
                    }
                },

                spawnNote() {
                    const cat = document.querySelector('.cat-container');
                    if (!cat) return;
                    const notes = ['â™ª', 'â™«', 'â™¬', 'ðŸŽµ', 'ðŸŽ¶'];
                    const note = document.createElement('span');
                    note.className = 'cat-note';
                    note.textContent = notes[Math.floor(Math.random() * notes.length)];
                    note.style.left = (Math.random() * 60 + 20) + 'px';
                    note.style.top = (Math.random() * 30) + 'px';
                    note.style.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                    cat.appendChild(note);
                    setTimeout(() => note.remove(), 2000);
                },

                spawnZzz() {
                    const cat = document.querySelector('.cat-container');
                    if (!cat) return;
                    const zzz = document.createElement('span');
                    zzz.className = 'cat-zzz';
                    zzz.textContent = 'Z';
                    zzz.style.left = (Math.random() * 40 + 30) + 'px';
                    zzz.style.top = '10px';
                    cat.appendChild(zzz);
                    setTimeout(() => zzz.remove(), 3000);
                },

                spawnHeart() {
                    const cat = document.querySelector('.cat-container');
                    if (!cat) return;
                    const heart = document.createElement('span');
                    heart.className = 'cat-heart';
                    heart.textContent = 'â¤ï¸';
                    heart.style.left = (Math.random() * 60 + 20) + 'px';
                    heart.style.top = (Math.random() * 20) + 'px';
                    cat.appendChild(heart);
                    setTimeout(() => heart.remove(), 1500);
                },

                spawnStar() {
                    const cat = document.querySelector('.cat-container');
                    if (!cat) return;
                    const star = document.createElement('span');
                    star.className = 'cat-star';
                    star.textContent = 'â­';
                    star.style.left = (Math.random() * 60 + 20) + 'px';
                    star.style.top = (Math.random() * 20) + 'px';
                    cat.appendChild(star);
                    setTimeout(() => star.remove(), 2000);
                },

                updateMood() {
                    const hour = new Date().getHours();
                    if (this.playing) {
                        this.mood = 'vibing';
                    } else if (hour >= 23 || hour < 6) {
                        this.mood = 'sleepy';
                    } else {
                        this.mood = 'content';
                    }
                },

                updateEyes() {
                    if (this.isDragging) return;

                    const catEl = document.querySelector('.cat-container');
                    if (!catEl) return;

                    const rect = catEl.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;

                    const angle = Math.atan2(this.mouseY - centerY, this.mouseX - centerX);
                    const distance = Math.min(5, Math.sqrt(Math.pow(this.mouseX - centerX, 2) + Math.pow(this.mouseY - centerY, 2)) / 50);

                    this.eyeOffsetX = Math.cos(angle) * distance;
                    this.eyeOffsetY = Math.sin(angle) * distance;
                },

                handleDrag(event) {
                    const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
                    const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

                    // Calculate target position from right/bottom
                    let targetX = (window.innerWidth - clientX) - this.dragOffsetX;
                    let targetY = (window.innerHeight - clientY) - this.dragOffsetY;

                    // Screen Boundaries (80px cat size, 20px margin)
                    const margin = 20;
                    const catSize = window.playAppInstance?.mobileMode ? 80 : 150;
                    const navPadding = window.playAppInstance?.mobileMode ? 100 : 40;

                    this.catX = Math.max(margin, Math.min(window.innerWidth - catSize - margin, targetX));
                    this.catY = Math.max(navPadding, Math.min(window.innerHeight - catSize - margin, targetY));
                },

                startDrag(event) {
                    this.isDragging = true;
                    const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
                    const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);

                    // Store the offset from the cat's bottom-right corner to the click point
                    this.dragOffsetX = (window.innerWidth - clientX) - this.catX;
                    this.dragOffsetY = (window.innerHeight - clientY) - this.catY;

                    const messages = ['Wheee! ðŸ™€', 'Put me down! ðŸ˜¹', 'I can fly! âœ¨', 'Higher! ðŸš€'];
                    this.showSpeech(messages[Math.floor(Math.random() * messages.length)], 1000);
                },

                stopDrag() {
                    this.isDragging = false;
                },

                updatePosition() {
                    if (!this.isDragging) {
                        const time = Date.now() / 2000;
                        const driftX = Math.sin(time) * 5;
                        const driftY = Math.cos(time * 0.8) * 3;

                        const targetX = 40 + driftX;
                        const targetY = 40 + driftY;

                        this.catX += (targetX - this.catX) * 0.05;
                        this.catY += (targetY - this.catY) * 0.05;
                    }
                },

                interactWithCat() {
                    const now = Date.now();
                    if (now - this.lastClickTime < 500) {
                        this.clickCount++;
                    } else {
                        this.clickCount = 1;
                    }
                    this.lastClickTime = now;

                    // Combo reactions based on click count
                    if (this.clickCount >= 5) {
                        this.showSpeech('ðŸŒŸ SUPER KITTY MODE! ðŸŒŸ', 2000);
                        this.isGlowing = true;
                        this.spawnStar();
                        this.spawnStar();
                        this.spawnHeart();
                        for (let i = 0; i < 5; i++) setTimeout(() => this.spawnNote(), i * 200);
                        setTimeout(() => this.isGlowing = false, 2000);
                        this.clickCount = 0;
                    } else if (this.clickCount >= 3) {
                        this.showSpeech('More pets! ðŸ’•', 1500);
                        this.isPurring = true;
                        this.spawnHeart();
                        this.spawnHeart();
                        setTimeout(() => this.isPurring = false, 1500);
                    } else {
                        const messages = [
                            'Purrr... ðŸŽ¶', 'I love this track!', 'Meow! ðŸ±',
                            'High five! ðŸ¾', 'Need more bass!', 'Aura is the best!',
                            '*purrs loudly*', 'Pet me more! ðŸ’œ', 'You\'re the best! â­',
                            'Let\'s party! ðŸŽ‰', 'Vibes on point! âœ¨'
                        ];
                        this.showSpeech(messages[Math.floor(Math.random() * messages.length)]);
                        this.spawnHeart();
                        this.isGlowing = true;
                        setTimeout(() => this.isGlowing = false, 1000);
                    }
                },

                showSpeech(text, duration = 3000) {
                    this.speechText = text;
                    this.speechVisible = true;
                    if (this.speechTimeout) clearTimeout(this.speechTimeout);
                    this.speechTimeout = setTimeout(() => this.speechVisible = false, duration);
                },

                hideSpeech() {
                    this.speechVisible = false;
                },

                async checkForNewSong() {
                    const playApp = window.playAppInstance;
                    if (playApp && playApp.currentSong) {
                        const currentTitle = playApp.currentSong.song?.title || playApp.currentSong.title;
                        if (currentTitle && currentTitle !== this.lastSongTitle) {
                            this.lastSongTitle = currentTitle;
                            const reactions = [
                                `ðŸŽµ "${currentTitle.substring(0, 20)}..." Nice!`,
                                'âœ¨ Ooh, new song!',
                                'ðŸŽ§ Great choice!',
                                'ðŸ’œ I love this one!',
                                'ðŸ”¥ This one\'s fire!'
                            ];
                            this.showSpeech(reactions[Math.floor(Math.random() * reactions.length)], 3000);
                            this.isGlowing = true;
                            this.spawnStar();
                            setTimeout(() => this.isGlowing = false, 2000);
                        }
                    }
                }
            }
        }
    </script>
    <!-- Friend & Room Client -->
    <script src="/static/friend-room-client.js"></script>
</body>

</html>